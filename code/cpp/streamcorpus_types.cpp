/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "streamcorpus_types.h"

#include <algorithm>

namespace streamcorpus {

int _kOffsetTypeValues[] = {
  OffsetType::LINES,
  OffsetType::BYTES,
  OffsetType::CHARS
};
const char* _kOffsetTypeNames[] = {
  "LINES",
  "BYTES",
  "CHARS"
};
const std::map<int, const char*> _OffsetType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kOffsetTypeValues, _kOffsetTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEntityTypeValues[] = {
  EntityType::PER,
  EntityType::ORG,
  EntityType::LOC,
  EntityType::MALE_PRONOUN,
  EntityType::FEMALE_PRONOUN,
  EntityType::TIME,
  EntityType::DATE,
  EntityType::MONEY,
  EntityType::PERCENT,
  EntityType::MISC
};
const char* _kEntityTypeNames[] = {
  "PER",
  "ORG",
  "LOC",
  "MALE_PRONOUN",
  "FEMALE_PRONOUN",
  "TIME",
  "DATE",
  "MONEY",
  "PERCENT",
  "MISC"
};
const std::map<int, const char*> _EntityType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kEntityTypeValues, _kEntityTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kVersionsValues[] = {
  Versions::v0_2_0
};
const char* _kVersionsNames[] = {
  "v0_2_0"
};
const std::map<int, const char*> _Versions_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kVersionsValues, _kVersionsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* StreamTime::ascii_fingerprint = "DD2684E5F49042C4C07B5348ECFFFD06";
const uint8_t StreamTime::binary_fingerprint[16] = {0xDD,0x26,0x84,0xE5,0xF4,0x90,0x42,0xC4,0xC0,0x7B,0x53,0x48,0xEC,0xFF,0xFD,0x06};

uint32_t StreamTime::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->epoch_ticks);
          this->__isset.epoch_ticks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zulu_timestamp);
          this->__isset.zulu_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StreamTime::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StreamTime");

  xfer += oprot->writeFieldBegin("epoch_ticks", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->epoch_ticks);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zulu_timestamp", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->zulu_timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StreamTime &a, StreamTime &b) {
  using ::std::swap;
  swap(a.epoch_ticks, b.epoch_ticks);
  swap(a.zulu_timestamp, b.zulu_timestamp);
  swap(a.__isset, b.__isset);
}

const char* Annotator::ascii_fingerprint = "8D64F3DD69187433CDFC330482190EEE";
const uint8_t Annotator::binary_fingerprint[16] = {0x8D,0x64,0xF3,0xDD,0x69,0x18,0x74,0x33,0xCD,0xFC,0x33,0x04,0x82,0x19,0x0E,0xEE};

uint32_t Annotator::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->annotator_id);
          this->__isset.annotator_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotation_time.read(iprot);
          this->__isset.annotation_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Annotator::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Annotator");

  xfer += oprot->writeFieldBegin("annotator_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->annotator_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.annotation_time) {
    xfer += oprot->writeFieldBegin("annotation_time", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->annotation_time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Annotator &a, Annotator &b) {
  using ::std::swap;
  swap(a.annotator_id, b.annotator_id);
  swap(a.annotation_time, b.annotation_time);
  swap(a.__isset, b.__isset);
}

const char* Offset::ascii_fingerprint = "A20D4C3BA289AF4627C9FDEC29A1B027";
const uint8_t Offset::binary_fingerprint[16] = {0xA2,0x0D,0x4C,0x3B,0xA2,0x89,0xAF,0x46,0x27,0xC9,0xFD,0xEC,0x29,0xA1,0xB0,0x27};

uint32_t Offset::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (OffsetType::type)ecast0;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->first);
          this->__isset.first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->xpath);
          this->__isset.xpath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content_form);
          this->__isset.content_form = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Offset::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Offset");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->first);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->length);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.xpath) {
    xfer += oprot->writeFieldBegin("xpath", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->xpath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.content_form) {
    xfer += oprot->writeFieldBegin("content_form", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->content_form);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Offset &a, Offset &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.first, b.first);
  swap(a.length, b.length);
  swap(a.xpath, b.xpath);
  swap(a.content_form, b.content_form);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* Target::ascii_fingerprint = "8F380763C4E93CCC138A5250BA588978";
const uint8_t Target::binary_fingerprint[16] = {0x8F,0x38,0x07,0x63,0xC4,0xE9,0x3C,0xCC,0x13,0x8A,0x52,0x50,0xBA,0x58,0x89,0x78};

uint32_t Target::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_id);
          this->__isset.target_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->kb_id);
          this->__isset.kb_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kb_snapshot_time.read(iprot);
          this->__isset.kb_snapshot_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Target::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Target");

  xfer += oprot->writeFieldBegin("target_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->target_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.kb_id) {
    xfer += oprot->writeFieldBegin("kb_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->kb_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kb_snapshot_time) {
    xfer += oprot->writeFieldBegin("kb_snapshot_time", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->kb_snapshot_time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Target &a, Target &b) {
  using ::std::swap;
  swap(a.target_id, b.target_id);
  swap(a.kb_id, b.kb_id);
  swap(a.kb_snapshot_time, b.kb_snapshot_time);
  swap(a.__isset, b.__isset);
}

const char* Label::ascii_fingerprint = "E98A9E5328B74B3E093000EBAED29699";
const uint8_t Label::binary_fingerprint[16] = {0xE9,0x8A,0x9E,0x53,0x28,0xB7,0x4B,0x3E,0x09,0x30,0x00,0xEB,0xAE,0xD2,0x96,0x99};

uint32_t Label::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotator.read(iprot);
          this->__isset.annotator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->target.read(iprot);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->offsets.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _ktype2;
            ::apache::thrift::protocol::TType _vtype3;
            xfer += iprot->readMapBegin(_ktype2, _vtype3, _size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              OffsetType::type _key6;
              int32_t ecast8;
              xfer += iprot->readI32(ecast8);
              _key6 = (OffsetType::type)ecast8;
              Offset& _val7 = this->offsets[_key6];
              xfer += _val7.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.offsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Label::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Label");

  xfer += oprot->writeFieldBegin("annotator", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->annotator.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->target.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offsets) {
    xfer += oprot->writeFieldBegin("offsets", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->offsets.size()));
      std::map<OffsetType::type, Offset> ::const_iterator _iter9;
      for (_iter9 = this->offsets.begin(); _iter9 != this->offsets.end(); ++_iter9)
      {
        xfer += oprot->writeI32((int32_t)_iter9->first);
        xfer += _iter9->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Label &a, Label &b) {
  using ::std::swap;
  swap(a.annotator, b.annotator);
  swap(a.target, b.target);
  swap(a.offsets, b.offsets);
  swap(a.__isset, b.__isset);
}

const char* Token::ascii_fingerprint = "BB9C1635CA9117F93E597FC9C8870305";
const uint8_t Token::binary_fingerprint[16] = {0xBB,0x9C,0x16,0x35,0xCA,0x91,0x17,0xF9,0x3E,0x59,0x7F,0xC9,0xC8,0x87,0x03,0x05};

uint32_t Token::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->token_num);
          this->__isset.token_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->offsets.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _ktype11;
            ::apache::thrift::protocol::TType _vtype12;
            xfer += iprot->readMapBegin(_ktype11, _vtype12, _size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              OffsetType::type _key15;
              int32_t ecast17;
              xfer += iprot->readI32(ecast17);
              _key15 = (OffsetType::type)ecast17;
              Offset& _val16 = this->offsets[_key15];
              xfer += _val16.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.offsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sentence_pos);
          this->__isset.sentence_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lemma);
          this->__isset.lemma = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->entity_type = (EntityType::type)ecast18;
          this->__isset.entity_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mention_id);
          this->__isset.mention_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->equiv_id);
          this->__isset.equiv_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->parent_id);
          this->__isset.parent_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dependency_path);
          this->__isset.dependency_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->labels.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _ktype20;
            ::apache::thrift::protocol::TType _vtype21;
            xfer += iprot->readMapBegin(_ktype20, _vtype21, _size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              AnnotatorID _key24;
              xfer += iprot->readString(_key24);
              std::vector<Label> & _val25 = this->labels[_key24];
              {
                _val25.clear();
                uint32_t _size26;
                ::apache::thrift::protocol::TType _etype29;
                xfer += iprot->readListBegin(_etype29, _size26);
                _val25.resize(_size26);
                uint32_t _i30;
                for (_i30 = 0; _i30 < _size26; ++_i30)
                {
                  xfer += _val25[_i30].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Token::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Token");

  xfer += oprot->writeFieldBegin("token_num", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->token_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->token);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offsets) {
    xfer += oprot->writeFieldBegin("offsets", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->offsets.size()));
      std::map<OffsetType::type, Offset> ::const_iterator _iter31;
      for (_iter31 = this->offsets.begin(); _iter31 != this->offsets.end(); ++_iter31)
      {
        xfer += oprot->writeI32((int32_t)_iter31->first);
        xfer += _iter31->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_pos) {
    xfer += oprot->writeFieldBegin("sentence_pos", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->sentence_pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lemma) {
    xfer += oprot->writeFieldBegin("lemma", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->lemma);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.entity_type) {
    xfer += oprot->writeFieldBegin("entity_type", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->entity_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mention_id) {
    xfer += oprot->writeFieldBegin("mention_id", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->mention_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.equiv_id) {
    xfer += oprot->writeFieldBegin("equiv_id", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->equiv_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parent_id) {
    xfer += oprot->writeFieldBegin("parent_id", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->parent_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dependency_path) {
    xfer += oprot->writeFieldBegin("dependency_path", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->dependency_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->labels.size()));
      std::map<AnnotatorID, std::vector<Label> > ::const_iterator _iter32;
      for (_iter32 = this->labels.begin(); _iter32 != this->labels.end(); ++_iter32)
      {
        xfer += oprot->writeString(_iter32->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter32->second.size()));
          std::vector<Label> ::const_iterator _iter33;
          for (_iter33 = _iter32->second.begin(); _iter33 != _iter32->second.end(); ++_iter33)
          {
            xfer += (*_iter33).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Token &a, Token &b) {
  using ::std::swap;
  swap(a.token_num, b.token_num);
  swap(a.token, b.token);
  swap(a.offsets, b.offsets);
  swap(a.sentence_pos, b.sentence_pos);
  swap(a.lemma, b.lemma);
  swap(a.pos, b.pos);
  swap(a.entity_type, b.entity_type);
  swap(a.mention_id, b.mention_id);
  swap(a.equiv_id, b.equiv_id);
  swap(a.parent_id, b.parent_id);
  swap(a.dependency_path, b.dependency_path);
  swap(a.labels, b.labels);
  swap(a.__isset, b.__isset);
}

const char* Sentence::ascii_fingerprint = "A437A51F43E711F534E8D04AE12A3D99";
const uint8_t Sentence::binary_fingerprint[16] = {0xA4,0x37,0xA5,0x1F,0x43,0xE7,0x11,0xF5,0x34,0xE8,0xD0,0x4A,0xE1,0x2A,0x3D,0x99};

uint32_t Sentence::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tokens.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _etype37;
            xfer += iprot->readListBegin(_etype37, _size34);
            this->tokens.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += this->tokens[_i38].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tokens = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->labels.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _ktype40;
            ::apache::thrift::protocol::TType _vtype41;
            xfer += iprot->readMapBegin(_ktype40, _vtype41, _size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              AnnotatorID _key44;
              xfer += iprot->readString(_key44);
              std::vector<Label> & _val45 = this->labels[_key44];
              {
                _val45.clear();
                uint32_t _size46;
                ::apache::thrift::protocol::TType _etype49;
                xfer += iprot->readListBegin(_etype49, _size46);
                _val45.resize(_size46);
                uint32_t _i50;
                for (_i50 = 0; _i50 < _size46; ++_i50)
                {
                  xfer += _val45[_i50].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Sentence::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Sentence");

  xfer += oprot->writeFieldBegin("tokens", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tokens.size()));
    std::vector<Token> ::const_iterator _iter51;
    for (_iter51 = this->tokens.begin(); _iter51 != this->tokens.end(); ++_iter51)
    {
      xfer += (*_iter51).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->labels.size()));
      std::map<AnnotatorID, std::vector<Label> > ::const_iterator _iter52;
      for (_iter52 = this->labels.begin(); _iter52 != this->labels.end(); ++_iter52)
      {
        xfer += oprot->writeString(_iter52->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter52->second.size()));
          std::vector<Label> ::const_iterator _iter53;
          for (_iter53 = _iter52->second.begin(); _iter53 != _iter52->second.end(); ++_iter53)
          {
            xfer += (*_iter53).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Sentence &a, Sentence &b) {
  using ::std::swap;
  swap(a.tokens, b.tokens);
  swap(a.labels, b.labels);
  swap(a.__isset, b.__isset);
}

const char* Tagging::ascii_fingerprint = "0A0DFB97882FDAD8FD6CF82C36CDF3B0";
const uint8_t Tagging::binary_fingerprint[16] = {0x0A,0x0D,0xFB,0x97,0x88,0x2F,0xDA,0xD8,0xFD,0x6C,0xF8,0x2C,0x36,0xCD,0xF3,0xB0};

uint32_t Tagging::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagger_id);
          this->__isset.tagger_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->raw_tagging);
          this->__isset.raw_tagging = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagger_config);
          this->__isset.tagger_config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagger_version);
          this->__isset.tagger_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->generation_time.read(iprot);
          this->__isset.generation_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Tagging::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Tagging");

  xfer += oprot->writeFieldBegin("tagger_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tagger_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raw_tagging", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->raw_tagging);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tagger_config) {
    xfer += oprot->writeFieldBegin("tagger_config", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->tagger_config);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tagger_version) {
    xfer += oprot->writeFieldBegin("tagger_version", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tagger_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.generation_time) {
    xfer += oprot->writeFieldBegin("generation_time", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->generation_time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Tagging &a, Tagging &b) {
  using ::std::swap;
  swap(a.tagger_id, b.tagger_id);
  swap(a.raw_tagging, b.raw_tagging);
  swap(a.tagger_config, b.tagger_config);
  swap(a.tagger_version, b.tagger_version);
  swap(a.generation_time, b.generation_time);
  swap(a.__isset, b.__isset);
}

const char* Language::ascii_fingerprint = "5B708A954C550ECA9C1A49D3C5CAFAB9";
const uint8_t Language::binary_fingerprint[16] = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

uint32_t Language::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Language::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Language");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Language &a, Language &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

const char* ContentItem::ascii_fingerprint = "487BE901B62B179EF8670F84FF3EA177";
const uint8_t ContentItem::binary_fingerprint[16] = {0x48,0x7B,0xE9,0x01,0xB6,0x2B,0x17,0x9E,0xF8,0x67,0x0F,0x84,0xFF,0x3E,0xA1,0x77};

uint32_t ContentItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->raw);
          this->__isset.raw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->encoding);
          this->__isset.encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->media_type);
          this->__isset.media_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clean_html);
          this->__isset.clean_html = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clean_visible);
          this->__isset.clean_visible = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->logs.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->logs.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += iprot->readString(this->logs[_i58]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.logs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->taggings.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _ktype60;
            ::apache::thrift::protocol::TType _vtype61;
            xfer += iprot->readMapBegin(_ktype60, _vtype61, _size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              TaggerID _key64;
              xfer += iprot->readString(_key64);
              Tagging& _val65 = this->taggings[_key64];
              xfer += _val65.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.taggings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->labels.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _ktype67;
            ::apache::thrift::protocol::TType _vtype68;
            xfer += iprot->readMapBegin(_ktype67, _vtype68, _size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              AnnotatorID _key71;
              xfer += iprot->readString(_key71);
              std::vector<Label> & _val72 = this->labels[_key71];
              {
                _val72.clear();
                uint32_t _size73;
                ::apache::thrift::protocol::TType _etype76;
                xfer += iprot->readListBegin(_etype76, _size73);
                _val72.resize(_size73);
                uint32_t _i77;
                for (_i77 = 0; _i77 < _size73; ++_i77)
                {
                  xfer += _val72[_i77].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->sentences.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _ktype79;
            ::apache::thrift::protocol::TType _vtype80;
            xfer += iprot->readMapBegin(_ktype79, _vtype80, _size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              TaggerID _key83;
              xfer += iprot->readString(_key83);
              std::vector<Sentence> & _val84 = this->sentences[_key83];
              {
                _val84.clear();
                uint32_t _size85;
                ::apache::thrift::protocol::TType _etype88;
                xfer += iprot->readListBegin(_etype88, _size85);
                _val84.resize(_size85);
                uint32_t _i89;
                for (_i89 = 0; _i89 < _size85; ++_i89)
                {
                  xfer += _val84[_i89].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.sentences = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->sentence_blobs.clear();
            uint32_t _size90;
            ::apache::thrift::protocol::TType _ktype91;
            ::apache::thrift::protocol::TType _vtype92;
            xfer += iprot->readMapBegin(_ktype91, _vtype92, _size90);
            uint32_t _i94;
            for (_i94 = 0; _i94 < _size90; ++_i94)
            {
              TaggerID _key95;
              xfer += iprot->readString(_key95);
              std::string& _val96 = this->sentence_blobs[_key95];
              xfer += iprot->readBinary(_val96);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.sentence_blobs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->language.read(iprot);
          this->__isset.language = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContentItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ContentItem");

  if (this->__isset.raw) {
    xfer += oprot->writeFieldBegin("raw", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->raw);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encoding) {
    xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->encoding);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.media_type) {
    xfer += oprot->writeFieldBegin("media_type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->media_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clean_html) {
    xfer += oprot->writeFieldBegin("clean_html", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->clean_html);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clean_visible) {
    xfer += oprot->writeFieldBegin("clean_visible", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->clean_visible);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logs) {
    xfer += oprot->writeFieldBegin("logs", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->logs.size()));
      std::vector<std::string> ::const_iterator _iter97;
      for (_iter97 = this->logs.begin(); _iter97 != this->logs.end(); ++_iter97)
      {
        xfer += oprot->writeString((*_iter97));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.taggings) {
    xfer += oprot->writeFieldBegin("taggings", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->taggings.size()));
      std::map<TaggerID, Tagging> ::const_iterator _iter98;
      for (_iter98 = this->taggings.begin(); _iter98 != this->taggings.end(); ++_iter98)
      {
        xfer += oprot->writeString(_iter98->first);
        xfer += _iter98->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->labels.size()));
      std::map<AnnotatorID, std::vector<Label> > ::const_iterator _iter99;
      for (_iter99 = this->labels.begin(); _iter99 != this->labels.end(); ++_iter99)
      {
        xfer += oprot->writeString(_iter99->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter99->second.size()));
          std::vector<Label> ::const_iterator _iter100;
          for (_iter100 = _iter99->second.begin(); _iter100 != _iter99->second.end(); ++_iter100)
          {
            xfer += (*_iter100).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentences) {
    xfer += oprot->writeFieldBegin("sentences", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->sentences.size()));
      std::map<TaggerID, std::vector<Sentence> > ::const_iterator _iter101;
      for (_iter101 = this->sentences.begin(); _iter101 != this->sentences.end(); ++_iter101)
      {
        xfer += oprot->writeString(_iter101->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter101->second.size()));
          std::vector<Sentence> ::const_iterator _iter102;
          for (_iter102 = _iter101->second.begin(); _iter102 != _iter101->second.end(); ++_iter102)
          {
            xfer += (*_iter102).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_blobs) {
    xfer += oprot->writeFieldBegin("sentence_blobs", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sentence_blobs.size()));
      std::map<TaggerID, std::string> ::const_iterator _iter103;
      for (_iter103 = this->sentence_blobs.begin(); _iter103 != this->sentence_blobs.end(); ++_iter103)
      {
        xfer += oprot->writeString(_iter103->first);
        xfer += oprot->writeBinary(_iter103->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.language) {
    xfer += oprot->writeFieldBegin("language", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->language.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContentItem &a, ContentItem &b) {
  using ::std::swap;
  swap(a.raw, b.raw);
  swap(a.encoding, b.encoding);
  swap(a.media_type, b.media_type);
  swap(a.clean_html, b.clean_html);
  swap(a.clean_visible, b.clean_visible);
  swap(a.logs, b.logs);
  swap(a.taggings, b.taggings);
  swap(a.labels, b.labels);
  swap(a.sentences, b.sentences);
  swap(a.sentence_blobs, b.sentence_blobs);
  swap(a.language, b.language);
  swap(a.__isset, b.__isset);
}

const char* Rating::ascii_fingerprint = "DCBA8CB33AD8DD99F9FD43759B321154";
const uint8_t Rating::binary_fingerprint[16] = {0xDC,0xBA,0x8C,0xB3,0x3A,0xD8,0xDD,0x99,0xF9,0xFD,0x43,0x75,0x9B,0x32,0x11,0x54};

uint32_t Rating::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotator.read(iprot);
          this->__isset.annotator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->target.read(iprot);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->relevance);
          this->__isset.relevance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->contains_mention);
          this->__isset.contains_mention = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comments);
          this->__isset.comments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mentions.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->mentions.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              xfer += iprot->readString(this->mentions[_i108]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mentions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Rating::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Rating");

  xfer += oprot->writeFieldBegin("annotator", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->annotator.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->target.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.relevance) {
    xfer += oprot->writeFieldBegin("relevance", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->relevance);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.contains_mention) {
    xfer += oprot->writeFieldBegin("contains_mention", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->contains_mention);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comments) {
    xfer += oprot->writeFieldBegin("comments", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->comments);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mentions) {
    xfer += oprot->writeFieldBegin("mentions", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->mentions.size()));
      std::vector<std::string> ::const_iterator _iter109;
      for (_iter109 = this->mentions.begin(); _iter109 != this->mentions.end(); ++_iter109)
      {
        xfer += oprot->writeString((*_iter109));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Rating &a, Rating &b) {
  using ::std::swap;
  swap(a.annotator, b.annotator);
  swap(a.target, b.target);
  swap(a.relevance, b.relevance);
  swap(a.contains_mention, b.contains_mention);
  swap(a.comments, b.comments);
  swap(a.mentions, b.mentions);
  swap(a.__isset, b.__isset);
}

const char* StreamItem::ascii_fingerprint = "F0D6A9AADC4FBB1DC66080270058F371";
const uint8_t StreamItem::binary_fingerprint[16] = {0xF0,0xD6,0xA9,0xAA,0xDC,0x4F,0xBB,0x1D,0xC6,0x60,0x80,0x27,0x00,0x58,0xF3,0x71};

uint32_t StreamItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast110;
          xfer += iprot->readI32(ecast110);
          this->version = (Versions::type)ecast110;
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->doc_id);
          this->__isset.doc_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->abs_url);
          this->__isset.abs_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schost);
          this->__isset.schost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->original_url);
          this->__isset.original_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->source_metadata.clear();
            uint32_t _size111;
            ::apache::thrift::protocol::TType _ktype112;
            ::apache::thrift::protocol::TType _vtype113;
            xfer += iprot->readMapBegin(_ktype112, _vtype113, _size111);
            uint32_t _i115;
            for (_i115 = 0; _i115 < _size111; ++_i115)
            {
              std::string _key116;
              xfer += iprot->readString(_key116);
              SourceMetadata& _val117 = this->source_metadata[_key116];
              xfer += iprot->readBinary(_val117);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.source_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stream_id);
          this->__isset.stream_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stream_time.read(iprot);
          this->__isset.stream_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->other_content.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _ktype119;
            ::apache::thrift::protocol::TType _vtype120;
            xfer += iprot->readMapBegin(_ktype119, _vtype120, _size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              std::string _key123;
              xfer += iprot->readString(_key123);
              ContentItem& _val124 = this->other_content[_key123];
              xfer += _val124.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.other_content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ratings.clear();
            uint32_t _size125;
            ::apache::thrift::protocol::TType _ktype126;
            ::apache::thrift::protocol::TType _vtype127;
            xfer += iprot->readMapBegin(_ktype126, _vtype127, _size125);
            uint32_t _i129;
            for (_i129 = 0; _i129 < _size125; ++_i129)
            {
              AnnotatorID _key130;
              xfer += iprot->readString(_key130);
              std::vector<Rating> & _val131 = this->ratings[_key130];
              {
                _val131.clear();
                uint32_t _size132;
                ::apache::thrift::protocol::TType _etype135;
                xfer += iprot->readListBegin(_etype135, _size132);
                _val131.resize(_size132);
                uint32_t _i136;
                for (_i136 = 0; _i136 < _size132; ++_i136)
                {
                  xfer += _val131[_i136].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ratings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StreamItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StreamItem");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("doc_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->doc_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.abs_url) {
    xfer += oprot->writeFieldBegin("abs_url", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->abs_url);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schost) {
    xfer += oprot->writeFieldBegin("schost", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->schost);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.original_url) {
    xfer += oprot->writeFieldBegin("original_url", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->original_url);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source) {
    xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->source);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.body) {
    xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->body.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source_metadata) {
    xfer += oprot->writeFieldBegin("source_metadata", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->source_metadata.size()));
      std::map<std::string, SourceMetadata> ::const_iterator _iter137;
      for (_iter137 = this->source_metadata.begin(); _iter137 != this->source_metadata.end(); ++_iter137)
      {
        xfer += oprot->writeString(_iter137->first);
        xfer += oprot->writeBinary(_iter137->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("stream_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->stream_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stream_time", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->stream_time.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.other_content) {
    xfer += oprot->writeFieldBegin("other_content", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->other_content.size()));
      std::map<std::string, ContentItem> ::const_iterator _iter138;
      for (_iter138 = this->other_content.begin(); _iter138 != this->other_content.end(); ++_iter138)
      {
        xfer += oprot->writeString(_iter138->first);
        xfer += _iter138->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ratings) {
    xfer += oprot->writeFieldBegin("ratings", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->ratings.size()));
      std::map<AnnotatorID, std::vector<Rating> > ::const_iterator _iter139;
      for (_iter139 = this->ratings.begin(); _iter139 != this->ratings.end(); ++_iter139)
      {
        xfer += oprot->writeString(_iter139->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter139->second.size()));
          std::vector<Rating> ::const_iterator _iter140;
          for (_iter140 = _iter139->second.begin(); _iter140 != _iter139->second.end(); ++_iter140)
          {
            xfer += (*_iter140).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StreamItem &a, StreamItem &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.doc_id, b.doc_id);
  swap(a.abs_url, b.abs_url);
  swap(a.schost, b.schost);
  swap(a.original_url, b.original_url);
  swap(a.source, b.source);
  swap(a.body, b.body);
  swap(a.source_metadata, b.source_metadata);
  swap(a.stream_id, b.stream_id);
  swap(a.stream_time, b.stream_time);
  swap(a.other_content, b.other_content);
  swap(a.ratings, b.ratings);
  swap(a.__isset, b.__isset);
}

} // namespace
