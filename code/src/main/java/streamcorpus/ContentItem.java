/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package streamcorpus;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;
import org.apache.thrift.scheme.TupleScheme;

/**
 * ContentItem contains raw data, an indication of its character encoding, and various transformed
 * versions of the raw data.
 */
public class ContentItem implements org.apache.thrift.TBase<ContentItem, ContentItem._Fields>, java.io.Serializable,
		Cloneable, Comparable<ContentItem> {
	private static final org.apache.thrift.protocol.TStruct						STRUCT_DESC								= new org.apache.thrift.protocol.TStruct(
																																																	"ContentItem");

	private static final org.apache.thrift.protocol.TField						RAW_FIELD_DESC						= new org.apache.thrift.protocol.TField(
																																																	"raw",
																																																	org.apache.thrift.protocol.TType.STRING,
																																																	(short) 1);
	private static final org.apache.thrift.protocol.TField						ENCODING_FIELD_DESC				= new org.apache.thrift.protocol.TField(
																																																	"encoding",
																																																	org.apache.thrift.protocol.TType.STRING,
																																																	(short) 2);
	private static final org.apache.thrift.protocol.TField						MEDIA_TYPE_FIELD_DESC			= new org.apache.thrift.protocol.TField(
																																																	"media_type",
																																																	org.apache.thrift.protocol.TType.STRING,
																																																	(short) 3);
	private static final org.apache.thrift.protocol.TField						CLEAN_HTML_FIELD_DESC			= new org.apache.thrift.protocol.TField(
																																																	"clean_html",
																																																	org.apache.thrift.protocol.TType.STRING,
																																																	(short) 4);
	private static final org.apache.thrift.protocol.TField						CLEAN_VISIBLE_FIELD_DESC	= new org.apache.thrift.protocol.TField(
																																																	"clean_visible",
																																																	org.apache.thrift.protocol.TType.STRING,
																																																	(short) 5);
	private static final org.apache.thrift.protocol.TField						LOGS_FIELD_DESC						= new org.apache.thrift.protocol.TField(
																																																	"logs",
																																																	org.apache.thrift.protocol.TType.LIST,
																																																	(short) 6);
	private static final org.apache.thrift.protocol.TField						TAGGINGS_FIELD_DESC				= new org.apache.thrift.protocol.TField(
																																																	"taggings",
																																																	org.apache.thrift.protocol.TType.MAP,
																																																	(short) 7);
	private static final org.apache.thrift.protocol.TField						LABELS_FIELD_DESC					= new org.apache.thrift.protocol.TField(
																																																	"labels",
																																																	org.apache.thrift.protocol.TType.MAP,
																																																	(short) 8);
	private static final org.apache.thrift.protocol.TField						SENTENCES_FIELD_DESC			= new org.apache.thrift.protocol.TField(
																																																	"sentences",
																																																	org.apache.thrift.protocol.TType.MAP,
																																																	(short) 9);
	private static final org.apache.thrift.protocol.TField						SENTENCE_BLOBS_FIELD_DESC	= new org.apache.thrift.protocol.TField(
																																																	"sentence_blobs",
																																																	org.apache.thrift.protocol.TType.MAP,
																																																	(short) 10);
	private static final org.apache.thrift.protocol.TField						LANGUAGE_FIELD_DESC				= new org.apache.thrift.protocol.TField(
																																																	"language",
																																																	org.apache.thrift.protocol.TType.STRUCT,
																																																	(short) 11);

	private static final Map<Class<? extends IScheme>, SchemeFactory>	schemes										= new HashMap<Class<? extends IScheme>, SchemeFactory>();
	static {
		schemes.put(StandardScheme.class, new ContentItemStandardSchemeFactory());
		schemes.put(TupleScheme.class, new ContentItemTupleSchemeFactory());
	}

	/**
	 * original download, raw byte array
	 */
	public ByteBuffer																									raw;																																								// optional
	/**
	 * guessed from raw and/or headers, e.g. by python-requests.org
	 */
	public String																											encoding;																																					// optional
	/**
	 * Content-type header from fetching the data, or MIME type
	 */
	public String																											media_type;																																				// optional
	/**
	 * HTML-formatted version of raw with UTF8 encoding and no broken tags. All HTML-escaped
	 * characters are converted to their UTF8 equivalents. < > & are escaped.
	 */
	public String																											clean_html;																																				// optional
	/**
	 * All tags stripped from clean_html and replaced with whitespace, so they have the same byte
	 * offsets. The only escaped characters are < > &, so that this can be treated as Character Data
	 * in XML: http://www.w3.org/TR/xml/#syntax
	 * 
	 * Again: must be UTF8
	 */
	public String																											clean_visible;																																			// optional
	/**
	 * Logs generated from processing pipeline, for forensics
	 */
	public List<String>																								logs;																																							// optional
	/**
	 * A set of auto-generated taggings, such as a One-Word-Per-Line (OWLP) tokenization and sentence
	 * chunking with part-of-speech, lemmatization, and NER classification. The string name should be
	 * the same as the tagger_id and also corresponds to the key in sentences or sentence_blobs, which
	 * get generated by transforming a Tagging.raw_tagging into Sentence and Token instances
	 * 
	 * Taggings are generated from 'clean_visible' so offsets (byte, char, line) refer to
	 * clean_visible and clean_html -- not raw.
	 */
	public Map<String, Tagging>																				taggings;																																					// optional
	/**
	 * sets of annotations
	 */
	public Map<String, List<Label>>																		labels;																																						// optional
	/**
	 * parsed Sentence objects generated by an NLP pipeline identified by the string name, which is a
	 * tagger_id that connects this Sentences instance to the Tagging struct from which it came
	 */
	public Map<String, List<Sentence>>																sentences;																																					// optional
	/**
	 * same as 'sentences' except the array of Sentence instances are serialized into a binary string
	 * that can be read by the Thrift's binary protocol. This allows lazy deserialization via an
	 * iterator -- one sentence at a time. This might be totally unnecessary, because at least some of
	 * the Thrift language implementations have lazy object construction, e.g. --gen py:dynamic,slots
	 */
	public Map<String, ByteBuffer>																		sentence_blobs;																																		// optional
	/**
	 * indication of which natural language is used in the text
	 */
	public Language																										language;																																					// optional

	/**
	 * The set of fields this struct contains, along with convenience methods for finding and
	 * manipulating them.
	 */
	public enum _Fields implements org.apache.thrift.TFieldIdEnum {
		/**
		 * original download, raw byte array
		 */
		RAW((short) 1, "raw"),
		/**
		 * guessed from raw and/or headers, e.g. by python-requests.org
		 */
		ENCODING((short) 2, "encoding"),
		/**
		 * Content-type header from fetching the data, or MIME type
		 */
		MEDIA_TYPE((short) 3, "media_type"),
		/**
		 * HTML-formatted version of raw with UTF8 encoding and no broken tags. All HTML-escaped
		 * characters are converted to their UTF8 equivalents. < > & are escaped.
		 */
		CLEAN_HTML((short) 4, "clean_html"),
		/**
		 * All tags stripped from clean_html and replaced with whitespace, so they have the same byte
		 * offsets. The only escaped characters are < > &, so that this can be treated as Character Data
		 * in XML: http://www.w3.org/TR/xml/#syntax
		 * 
		 * Again: must be UTF8
		 */
		CLEAN_VISIBLE((short) 5, "clean_visible"),
		/**
		 * Logs generated from processing pipeline, for forensics
		 */
		LOGS((short) 6, "logs"),
		/**
		 * A set of auto-generated taggings, such as a One-Word-Per-Line (OWLP) tokenization and
		 * sentence chunking with part-of-speech, lemmatization, and NER classification. The string name
		 * should be the same as the tagger_id and also corresponds to the key in sentences or
		 * sentence_blobs, which get generated by transforming a Tagging.raw_tagging into Sentence and
		 * Token instances
		 * 
		 * Taggings are generated from 'clean_visible' so offsets (byte, char, line) refer to
		 * clean_visible and clean_html -- not raw.
		 */
		TAGGINGS((short) 7, "taggings"),
		/**
		 * sets of annotations
		 */
		LABELS((short) 8, "labels"),
		/**
		 * parsed Sentence objects generated by an NLP pipeline identified by the string name, which is
		 * a tagger_id that connects this Sentences instance to the Tagging struct from which it came
		 */
		SENTENCES((short) 9, "sentences"),
		/**
		 * same as 'sentences' except the array of Sentence instances are serialized into a binary
		 * string that can be read by the Thrift's binary protocol. This allows lazy deserialization via
		 * an iterator -- one sentence at a time. This might be totally unnecessary, because at least
		 * some of the Thrift language implementations have lazy object construction, e.g. --gen
		 * py:dynamic,slots
		 */
		SENTENCE_BLOBS((short) 10, "sentence_blobs"),
		/**
		 * indication of which natural language is used in the text
		 */
		LANGUAGE((short) 11, "language");

		private static final Map<String, _Fields>	byName	= new HashMap<String, _Fields>();

		static {
			for (_Fields field : EnumSet.allOf(_Fields.class)) {
				byName.put(field.getFieldName(), field);
			}
		}

		/**
		 * Find the _Fields constant that matches fieldId, or null if its not found.
		 */
		public static _Fields findByThriftId(int fieldId) {
			switch (fieldId) {
			case 1: // RAW
				return RAW;
			case 2: // ENCODING
				return ENCODING;
			case 3: // MEDIA_TYPE
				return MEDIA_TYPE;
			case 4: // CLEAN_HTML
				return CLEAN_HTML;
			case 5: // CLEAN_VISIBLE
				return CLEAN_VISIBLE;
			case 6: // LOGS
				return LOGS;
			case 7: // TAGGINGS
				return TAGGINGS;
			case 8: // LABELS
				return LABELS;
			case 9: // SENTENCES
				return SENTENCES;
			case 10: // SENTENCE_BLOBS
				return SENTENCE_BLOBS;
			case 11: // LANGUAGE
				return LANGUAGE;
			default:
				return null;
			}
		}

		/**
		 * Find the _Fields constant that matches fieldId, throwing an exception if it is not found.
		 */
		public static _Fields findByThriftIdOrThrow(int fieldId) {
			_Fields fields = findByThriftId(fieldId);
			if (fields == null)
				throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
			return fields;
		}

		/**
		 * Find the _Fields constant that matches name, or null if its not found.
		 */
		public static _Fields findByName(String name) {
			return byName.get(name);
		}

		private final short		_thriftId;
		private final String	_fieldName;

		_Fields(short thriftId, String fieldName) {
			_thriftId = thriftId;
			_fieldName = fieldName;
		}

		@Override
		public short getThriftFieldId() {
			return _thriftId;
		}

		@Override
		public String getFieldName() {
			return _fieldName;
		}
	}

	// isset id assignments
	private _Fields																															optionals[]	= { _Fields.RAW,
			_Fields.ENCODING, _Fields.MEDIA_TYPE, _Fields.CLEAN_HTML, _Fields.CLEAN_VISIBLE, _Fields.LOGS, _Fields.TAGGINGS,
			_Fields.LABELS, _Fields.SENTENCES, _Fields.SENTENCE_BLOBS, _Fields.LANGUAGE				};
	public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData>	metaDataMap;
	static {
		Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(
				_Fields.class);
		tmpMap.put(_Fields.RAW, new org.apache.thrift.meta_data.FieldMetaData("raw",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.STRING, true)));
		tmpMap.put(_Fields.ENCODING, new org.apache.thrift.meta_data.FieldMetaData("encoding",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.STRING)));
		tmpMap.put(_Fields.MEDIA_TYPE, new org.apache.thrift.meta_data.FieldMetaData("media_type",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.STRING)));
		tmpMap.put(_Fields.CLEAN_HTML, new org.apache.thrift.meta_data.FieldMetaData("clean_html",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.STRING)));
		tmpMap.put(_Fields.CLEAN_VISIBLE, new org.apache.thrift.meta_data.FieldMetaData("clean_visible",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.STRING)));
		tmpMap.put(_Fields.LOGS, new org.apache.thrift.meta_data.FieldMetaData("logs",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.ListMetaData(
						org.apache.thrift.protocol.TType.LIST, new org.apache.thrift.meta_data.FieldValueMetaData(
								org.apache.thrift.protocol.TType.STRING))));
		tmpMap.put(_Fields.TAGGINGS, new org.apache.thrift.meta_data.FieldMetaData("taggings",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.MapMetaData(
						org.apache.thrift.protocol.TType.MAP, new org.apache.thrift.meta_data.FieldValueMetaData(
								org.apache.thrift.protocol.TType.STRING, "TaggerID"), new org.apache.thrift.meta_data.StructMetaData(
								org.apache.thrift.protocol.TType.STRUCT, Tagging.class))));
		tmpMap.put(_Fields.LABELS, new org.apache.thrift.meta_data.FieldMetaData("labels",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.MapMetaData(
						org.apache.thrift.protocol.TType.MAP, new org.apache.thrift.meta_data.FieldValueMetaData(
								org.apache.thrift.protocol.TType.STRING, "AnnotatorID"), new org.apache.thrift.meta_data.ListMetaData(
								org.apache.thrift.protocol.TType.LIST, new org.apache.thrift.meta_data.StructMetaData(
										org.apache.thrift.protocol.TType.STRUCT, Label.class)))));
		tmpMap.put(_Fields.SENTENCES, new org.apache.thrift.meta_data.FieldMetaData("sentences",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.MapMetaData(
						org.apache.thrift.protocol.TType.MAP, new org.apache.thrift.meta_data.FieldValueMetaData(
								org.apache.thrift.protocol.TType.STRING, "TaggerID"), new org.apache.thrift.meta_data.ListMetaData(
								org.apache.thrift.protocol.TType.LIST, new org.apache.thrift.meta_data.StructMetaData(
										org.apache.thrift.protocol.TType.STRUCT, Sentence.class)))));
		tmpMap.put(_Fields.SENTENCE_BLOBS, new org.apache.thrift.meta_data.FieldMetaData("sentence_blobs",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.MapMetaData(
						org.apache.thrift.protocol.TType.MAP, new org.apache.thrift.meta_data.FieldValueMetaData(
								org.apache.thrift.protocol.TType.STRING, "TaggerID"),
						new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING, true))));
		tmpMap.put(_Fields.LANGUAGE, new org.apache.thrift.meta_data.FieldMetaData("language",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.StructMetaData(
						org.apache.thrift.protocol.TType.STRUCT, Language.class)));
		metaDataMap = Collections.unmodifiableMap(tmpMap);
		org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(ContentItem.class, metaDataMap);
	}

	public ContentItem() {
		this.logs = new ArrayList<String>();

		this.taggings = new HashMap<String, Tagging>();

		this.labels = new HashMap<String, List<Label>>();

		this.sentences = new HashMap<String, List<Sentence>>();

		this.sentence_blobs = new HashMap<String, ByteBuffer>();

	}

	/**
	 * Performs a deep copy on <i>other</i>.
	 */
	public ContentItem(ContentItem other) {
		if (other.isSetRaw()) {
			this.raw = org.apache.thrift.TBaseHelper.copyBinary(other.raw);
			;
		}
		if (other.isSetEncoding()) {
			this.encoding = other.encoding;
		}
		if (other.isSetMedia_type()) {
			this.media_type = other.media_type;
		}
		if (other.isSetClean_html()) {
			this.clean_html = other.clean_html;
		}
		if (other.isSetClean_visible()) {
			this.clean_visible = other.clean_visible;
		}
		if (other.isSetLogs()) {
			List<String> __this__logs = new ArrayList<String>();
			for (String other_element : other.logs) {
				__this__logs.add(other_element);
			}
			this.logs = __this__logs;
		}
		if (other.isSetTaggings()) {
			Map<String, Tagging> __this__taggings = new HashMap<String, Tagging>();
			for (Map.Entry<String, Tagging> other_element : other.taggings.entrySet()) {

				String other_element_key = other_element.getKey();
				Tagging other_element_value = other_element.getValue();

				String __this__taggings_copy_key = other_element_key;

				Tagging __this__taggings_copy_value = new Tagging(other_element_value);

				__this__taggings.put(__this__taggings_copy_key, __this__taggings_copy_value);
			}
			this.taggings = __this__taggings;
		}
		if (other.isSetLabels()) {
			Map<String, List<Label>> __this__labels = new HashMap<String, List<Label>>();
			for (Map.Entry<String, List<Label>> other_element : other.labels.entrySet()) {

				String other_element_key = other_element.getKey();
				List<Label> other_element_value = other_element.getValue();

				String __this__labels_copy_key = other_element_key;

				List<Label> __this__labels_copy_value = new ArrayList<Label>();
				for (Label other_element_value_element : other_element_value) {
					__this__labels_copy_value.add(new Label(other_element_value_element));
				}

				__this__labels.put(__this__labels_copy_key, __this__labels_copy_value);
			}
			this.labels = __this__labels;
		}
		if (other.isSetSentences()) {
			Map<String, List<Sentence>> __this__sentences = new HashMap<String, List<Sentence>>();
			for (Map.Entry<String, List<Sentence>> other_element : other.sentences.entrySet()) {

				String other_element_key = other_element.getKey();
				List<Sentence> other_element_value = other_element.getValue();

				String __this__sentences_copy_key = other_element_key;

				List<Sentence> __this__sentences_copy_value = new ArrayList<Sentence>();
				for (Sentence other_element_value_element : other_element_value) {
					__this__sentences_copy_value.add(new Sentence(other_element_value_element));
				}

				__this__sentences.put(__this__sentences_copy_key, __this__sentences_copy_value);
			}
			this.sentences = __this__sentences;
		}
		if (other.isSetSentence_blobs()) {
			Map<String, ByteBuffer> __this__sentence_blobs = new HashMap<String, ByteBuffer>();
			for (Map.Entry<String, ByteBuffer> other_element : other.sentence_blobs.entrySet()) {

				String other_element_key = other_element.getKey();
				ByteBuffer other_element_value = other_element.getValue();

				String __this__sentence_blobs_copy_key = other_element_key;

				ByteBuffer __this__sentence_blobs_copy_value = org.apache.thrift.TBaseHelper.copyBinary(other_element_value);
				;

				__this__sentence_blobs.put(__this__sentence_blobs_copy_key, __this__sentence_blobs_copy_value);
			}
			this.sentence_blobs = __this__sentence_blobs;
		}
		if (other.isSetLanguage()) {
			this.language = new Language(other.language);
		}
	}

	@Override
	public ContentItem deepCopy() {
		return new ContentItem(this);
	}

	@Override
	public void clear() {
		this.raw = null;
		this.encoding = null;
		this.media_type = null;
		this.clean_html = null;
		this.clean_visible = null;
		this.logs = new ArrayList<String>();

		this.taggings = new HashMap<String, Tagging>();

		this.labels = new HashMap<String, List<Label>>();

		this.sentences = new HashMap<String, List<Sentence>>();

		this.sentence_blobs = new HashMap<String, ByteBuffer>();

		this.language = null;
	}

	/**
	 * original download, raw byte array
	 */
	public byte[] getRaw() {
		setRaw(org.apache.thrift.TBaseHelper.rightSize(raw));
		return raw == null ? null : raw.array();
	}

	public ByteBuffer bufferForRaw() {
		return raw;
	}

	/**
	 * original download, raw byte array
	 */
	public ContentItem setRaw(byte[] raw) {
		setRaw(raw == null ? (ByteBuffer) null : ByteBuffer.wrap(raw));
		return this;
	}

	public ContentItem setRaw(ByteBuffer raw) {
		this.raw = raw;
		return this;
	}

	public void unsetRaw() {
		this.raw = null;
	}

	/** Returns true if field raw is set (has been assigned a value) and false otherwise */
	public boolean isSetRaw() {
		return this.raw != null;
	}

	public void setRawIsSet(boolean value) {
		if (!value) {
			this.raw = null;
		}
	}

	/**
	 * guessed from raw and/or headers, e.g. by python-requests.org
	 */
	public String getEncoding() {
		return this.encoding;
	}

	/**
	 * guessed from raw and/or headers, e.g. by python-requests.org
	 */
	public ContentItem setEncoding(String encoding) {
		this.encoding = encoding;
		return this;
	}

	public void unsetEncoding() {
		this.encoding = null;
	}

	/** Returns true if field encoding is set (has been assigned a value) and false otherwise */
	public boolean isSetEncoding() {
		return this.encoding != null;
	}

	public void setEncodingIsSet(boolean value) {
		if (!value) {
			this.encoding = null;
		}
	}

	/**
	 * Content-type header from fetching the data, or MIME type
	 */
	public String getMedia_type() {
		return this.media_type;
	}

	/**
	 * Content-type header from fetching the data, or MIME type
	 */
	public ContentItem setMedia_type(String media_type) {
		this.media_type = media_type;
		return this;
	}

	public void unsetMedia_type() {
		this.media_type = null;
	}

	/** Returns true if field media_type is set (has been assigned a value) and false otherwise */
	public boolean isSetMedia_type() {
		return this.media_type != null;
	}

	public void setMedia_typeIsSet(boolean value) {
		if (!value) {
			this.media_type = null;
		}
	}

	/**
	 * HTML-formatted version of raw with UTF8 encoding and no broken tags. All HTML-escaped
	 * characters are converted to their UTF8 equivalents. < > & are escaped.
	 */
	public String getClean_html() {
		return this.clean_html;
	}

	/**
	 * HTML-formatted version of raw with UTF8 encoding and no broken tags. All HTML-escaped
	 * characters are converted to their UTF8 equivalents. < > & are escaped.
	 */
	public ContentItem setClean_html(String clean_html) {
		this.clean_html = clean_html;
		return this;
	}

	public void unsetClean_html() {
		this.clean_html = null;
	}

	/** Returns true if field clean_html is set (has been assigned a value) and false otherwise */
	public boolean isSetClean_html() {
		return this.clean_html != null;
	}

	public void setClean_htmlIsSet(boolean value) {
		if (!value) {
			this.clean_html = null;
		}
	}

	/**
	 * All tags stripped from clean_html and replaced with whitespace, so they have the same byte
	 * offsets. The only escaped characters are < > &, so that this can be treated as Character Data
	 * in XML: http://www.w3.org/TR/xml/#syntax
	 * 
	 * Again: must be UTF8
	 */
	public String getClean_visible() {
		return this.clean_visible;
	}

	/**
	 * All tags stripped from clean_html and replaced with whitespace, so they have the same byte
	 * offsets. The only escaped characters are < > &, so that this can be treated as Character Data
	 * in XML: http://www.w3.org/TR/xml/#syntax
	 * 
	 * Again: must be UTF8
	 */
	public ContentItem setClean_visible(String clean_visible) {
		this.clean_visible = clean_visible;
		return this;
	}

	public void unsetClean_visible() {
		this.clean_visible = null;
	}

	/** Returns true if field clean_visible is set (has been assigned a value) and false otherwise */
	public boolean isSetClean_visible() {
		return this.clean_visible != null;
	}

	public void setClean_visibleIsSet(boolean value) {
		if (!value) {
			this.clean_visible = null;
		}
	}

	public int getLogsSize() {
		return (this.logs == null) ? 0 : this.logs.size();
	}

	public java.util.Iterator<String> getLogsIterator() {
		return (this.logs == null) ? null : this.logs.iterator();
	}

	public void addToLogs(String elem) {
		if (this.logs == null) {
			this.logs = new ArrayList<String>();
		}
		this.logs.add(elem);
	}

	/**
	 * Logs generated from processing pipeline, for forensics
	 */
	public List<String> getLogs() {
		return this.logs;
	}

	/**
	 * Logs generated from processing pipeline, for forensics
	 */
	public ContentItem setLogs(List<String> logs) {
		this.logs = logs;
		return this;
	}

	public void unsetLogs() {
		this.logs = null;
	}

	/** Returns true if field logs is set (has been assigned a value) and false otherwise */
	public boolean isSetLogs() {
		return this.logs != null;
	}

	public void setLogsIsSet(boolean value) {
		if (!value) {
			this.logs = null;
		}
	}

	public int getTaggingsSize() {
		return (this.taggings == null) ? 0 : this.taggings.size();
	}

	public void putToTaggings(String key, Tagging val) {
		if (this.taggings == null) {
			this.taggings = new HashMap<String, Tagging>();
		}
		this.taggings.put(key, val);
	}

	/**
	 * A set of auto-generated taggings, such as a One-Word-Per-Line (OWLP) tokenization and sentence
	 * chunking with part-of-speech, lemmatization, and NER classification. The string name should be
	 * the same as the tagger_id and also corresponds to the key in sentences or sentence_blobs, which
	 * get generated by transforming a Tagging.raw_tagging into Sentence and Token instances
	 * 
	 * Taggings are generated from 'clean_visible' so offsets (byte, char, line) refer to
	 * clean_visible and clean_html -- not raw.
	 */
	public Map<String, Tagging> getTaggings() {
		return this.taggings;
	}

	/**
	 * A set of auto-generated taggings, such as a One-Word-Per-Line (OWLP) tokenization and sentence
	 * chunking with part-of-speech, lemmatization, and NER classification. The string name should be
	 * the same as the tagger_id and also corresponds to the key in sentences or sentence_blobs, which
	 * get generated by transforming a Tagging.raw_tagging into Sentence and Token instances
	 * 
	 * Taggings are generated from 'clean_visible' so offsets (byte, char, line) refer to
	 * clean_visible and clean_html -- not raw.
	 */
	public ContentItem setTaggings(Map<String, Tagging> taggings) {
		this.taggings = taggings;
		return this;
	}

	public void unsetTaggings() {
		this.taggings = null;
	}

	/** Returns true if field taggings is set (has been assigned a value) and false otherwise */
	public boolean isSetTaggings() {
		return this.taggings != null;
	}

	public void setTaggingsIsSet(boolean value) {
		if (!value) {
			this.taggings = null;
		}
	}

	public int getLabelsSize() {
		return (this.labels == null) ? 0 : this.labels.size();
	}

	public void putToLabels(String key, List<Label> val) {
		if (this.labels == null) {
			this.labels = new HashMap<String, List<Label>>();
		}
		this.labels.put(key, val);
	}

	/**
	 * sets of annotations
	 */
	public Map<String, List<Label>> getLabels() {
		return this.labels;
	}

	/**
	 * sets of annotations
	 */
	public ContentItem setLabels(Map<String, List<Label>> labels) {
		this.labels = labels;
		return this;
	}

	public void unsetLabels() {
		this.labels = null;
	}

	/** Returns true if field labels is set (has been assigned a value) and false otherwise */
	public boolean isSetLabels() {
		return this.labels != null;
	}

	public void setLabelsIsSet(boolean value) {
		if (!value) {
			this.labels = null;
		}
	}

	public int getSentencesSize() {
		return (this.sentences == null) ? 0 : this.sentences.size();
	}

	public void putToSentences(String key, List<Sentence> val) {
		if (this.sentences == null) {
			this.sentences = new HashMap<String, List<Sentence>>();
		}
		this.sentences.put(key, val);
	}

	/**
	 * parsed Sentence objects generated by an NLP pipeline identified by the string name, which is a
	 * tagger_id that connects this Sentences instance to the Tagging struct from which it came
	 */
	public Map<String, List<Sentence>> getSentences() {
		return this.sentences;
	}

	/**
	 * parsed Sentence objects generated by an NLP pipeline identified by the string name, which is a
	 * tagger_id that connects this Sentences instance to the Tagging struct from which it came
	 */
	public ContentItem setSentences(Map<String, List<Sentence>> sentences) {
		this.sentences = sentences;
		return this;
	}

	public void unsetSentences() {
		this.sentences = null;
	}

	/** Returns true if field sentences is set (has been assigned a value) and false otherwise */
	public boolean isSetSentences() {
		return this.sentences != null;
	}

	public void setSentencesIsSet(boolean value) {
		if (!value) {
			this.sentences = null;
		}
	}

	public int getSentence_blobsSize() {
		return (this.sentence_blobs == null) ? 0 : this.sentence_blobs.size();
	}

	public void putToSentence_blobs(String key, ByteBuffer val) {
		if (this.sentence_blobs == null) {
			this.sentence_blobs = new HashMap<String, ByteBuffer>();
		}
		this.sentence_blobs.put(key, val);
	}

	/**
	 * same as 'sentences' except the array of Sentence instances are serialized into a binary string
	 * that can be read by the Thrift's binary protocol. This allows lazy deserialization via an
	 * iterator -- one sentence at a time. This might be totally unnecessary, because at least some of
	 * the Thrift language implementations have lazy object construction, e.g. --gen py:dynamic,slots
	 */
	public Map<String, ByteBuffer> getSentence_blobs() {
		return this.sentence_blobs;
	}

	/**
	 * same as 'sentences' except the array of Sentence instances are serialized into a binary string
	 * that can be read by the Thrift's binary protocol. This allows lazy deserialization via an
	 * iterator -- one sentence at a time. This might be totally unnecessary, because at least some of
	 * the Thrift language implementations have lazy object construction, e.g. --gen py:dynamic,slots
	 */
	public ContentItem setSentence_blobs(Map<String, ByteBuffer> sentence_blobs) {
		this.sentence_blobs = sentence_blobs;
		return this;
	}

	public void unsetSentence_blobs() {
		this.sentence_blobs = null;
	}

	/** Returns true if field sentence_blobs is set (has been assigned a value) and false otherwise */
	public boolean isSetSentence_blobs() {
		return this.sentence_blobs != null;
	}

	public void setSentence_blobsIsSet(boolean value) {
		if (!value) {
			this.sentence_blobs = null;
		}
	}

	/**
	 * indication of which natural language is used in the text
	 */
	public Language getLanguage() {
		return this.language;
	}

	/**
	 * indication of which natural language is used in the text
	 */
	public ContentItem setLanguage(Language language) {
		this.language = language;
		return this;
	}

	public void unsetLanguage() {
		this.language = null;
	}

	/** Returns true if field language is set (has been assigned a value) and false otherwise */
	public boolean isSetLanguage() {
		return this.language != null;
	}

	public void setLanguageIsSet(boolean value) {
		if (!value) {
			this.language = null;
		}
	}

	@Override
	public void setFieldValue(_Fields field, Object value) {
		switch (field) {
		case RAW:
			if (value == null) {
				unsetRaw();
			} else {
				setRaw((ByteBuffer) value);
			}
			break;

		case ENCODING:
			if (value == null) {
				unsetEncoding();
			} else {
				setEncoding((String) value);
			}
			break;

		case MEDIA_TYPE:
			if (value == null) {
				unsetMedia_type();
			} else {
				setMedia_type((String) value);
			}
			break;

		case CLEAN_HTML:
			if (value == null) {
				unsetClean_html();
			} else {
				setClean_html((String) value);
			}
			break;

		case CLEAN_VISIBLE:
			if (value == null) {
				unsetClean_visible();
			} else {
				setClean_visible((String) value);
			}
			break;

		case LOGS:
			if (value == null) {
				unsetLogs();
			} else {
				setLogs((List<String>) value);
			}
			break;

		case TAGGINGS:
			if (value == null) {
				unsetTaggings();
			} else {
				setTaggings((Map<String, Tagging>) value);
			}
			break;

		case LABELS:
			if (value == null) {
				unsetLabels();
			} else {
				setLabels((Map<String, List<Label>>) value);
			}
			break;

		case SENTENCES:
			if (value == null) {
				unsetSentences();
			} else {
				setSentences((Map<String, List<Sentence>>) value);
			}
			break;

		case SENTENCE_BLOBS:
			if (value == null) {
				unsetSentence_blobs();
			} else {
				setSentence_blobs((Map<String, ByteBuffer>) value);
			}
			break;

		case LANGUAGE:
			if (value == null) {
				unsetLanguage();
			} else {
				setLanguage((Language) value);
			}
			break;

		}
	}

	@Override
	public Object getFieldValue(_Fields field) {
		switch (field) {
		case RAW:
			return getRaw();

		case ENCODING:
			return getEncoding();

		case MEDIA_TYPE:
			return getMedia_type();

		case CLEAN_HTML:
			return getClean_html();

		case CLEAN_VISIBLE:
			return getClean_visible();

		case LOGS:
			return getLogs();

		case TAGGINGS:
			return getTaggings();

		case LABELS:
			return getLabels();

		case SENTENCES:
			return getSentences();

		case SENTENCE_BLOBS:
			return getSentence_blobs();

		case LANGUAGE:
			return getLanguage();

		}
		throw new IllegalStateException();
	}

	/**
	 * Returns true if field corresponding to fieldID is set (has been assigned a value) and false
	 * otherwise
	 */
	@Override
	public boolean isSet(_Fields field) {
		if (field == null) {
			throw new IllegalArgumentException();
		}

		switch (field) {
		case RAW:
			return isSetRaw();
		case ENCODING:
			return isSetEncoding();
		case MEDIA_TYPE:
			return isSetMedia_type();
		case CLEAN_HTML:
			return isSetClean_html();
		case CLEAN_VISIBLE:
			return isSetClean_visible();
		case LOGS:
			return isSetLogs();
		case TAGGINGS:
			return isSetTaggings();
		case LABELS:
			return isSetLabels();
		case SENTENCES:
			return isSetSentences();
		case SENTENCE_BLOBS:
			return isSetSentence_blobs();
		case LANGUAGE:
			return isSetLanguage();
		}
		throw new IllegalStateException();
	}

	@Override
	public boolean equals(Object that) {
		if (that == null)
			return false;
		if (that instanceof ContentItem)
			return this.equals((ContentItem) that);
		return false;
	}

	public boolean equals(ContentItem that) {
		if (that == null)
			return false;

		boolean this_present_raw = true && this.isSetRaw();
		boolean that_present_raw = true && that.isSetRaw();
		if (this_present_raw || that_present_raw) {
			if (!(this_present_raw && that_present_raw))
				return false;
			if (!this.raw.equals(that.raw))
				return false;
		}

		boolean this_present_encoding = true && this.isSetEncoding();
		boolean that_present_encoding = true && that.isSetEncoding();
		if (this_present_encoding || that_present_encoding) {
			if (!(this_present_encoding && that_present_encoding))
				return false;
			if (!this.encoding.equals(that.encoding))
				return false;
		}

		boolean this_present_media_type = true && this.isSetMedia_type();
		boolean that_present_media_type = true && that.isSetMedia_type();
		if (this_present_media_type || that_present_media_type) {
			if (!(this_present_media_type && that_present_media_type))
				return false;
			if (!this.media_type.equals(that.media_type))
				return false;
		}

		boolean this_present_clean_html = true && this.isSetClean_html();
		boolean that_present_clean_html = true && that.isSetClean_html();
		if (this_present_clean_html || that_present_clean_html) {
			if (!(this_present_clean_html && that_present_clean_html))
				return false;
			if (!this.clean_html.equals(that.clean_html))
				return false;
		}

		boolean this_present_clean_visible = true && this.isSetClean_visible();
		boolean that_present_clean_visible = true && that.isSetClean_visible();
		if (this_present_clean_visible || that_present_clean_visible) {
			if (!(this_present_clean_visible && that_present_clean_visible))
				return false;
			if (!this.clean_visible.equals(that.clean_visible))
				return false;
		}

		boolean this_present_logs = true && this.isSetLogs();
		boolean that_present_logs = true && that.isSetLogs();
		if (this_present_logs || that_present_logs) {
			if (!(this_present_logs && that_present_logs))
				return false;
			if (!this.logs.equals(that.logs))
				return false;
		}

		boolean this_present_taggings = true && this.isSetTaggings();
		boolean that_present_taggings = true && that.isSetTaggings();
		if (this_present_taggings || that_present_taggings) {
			if (!(this_present_taggings && that_present_taggings))
				return false;
			if (!this.taggings.equals(that.taggings))
				return false;
		}

		boolean this_present_labels = true && this.isSetLabels();
		boolean that_present_labels = true && that.isSetLabels();
		if (this_present_labels || that_present_labels) {
			if (!(this_present_labels && that_present_labels))
				return false;
			if (!this.labels.equals(that.labels))
				return false;
		}

		boolean this_present_sentences = true && this.isSetSentences();
		boolean that_present_sentences = true && that.isSetSentences();
		if (this_present_sentences || that_present_sentences) {
			if (!(this_present_sentences && that_present_sentences))
				return false;
			if (!this.sentences.equals(that.sentences))
				return false;
		}

		boolean this_present_sentence_blobs = true && this.isSetSentence_blobs();
		boolean that_present_sentence_blobs = true && that.isSetSentence_blobs();
		if (this_present_sentence_blobs || that_present_sentence_blobs) {
			if (!(this_present_sentence_blobs && that_present_sentence_blobs))
				return false;
			if (!this.sentence_blobs.equals(that.sentence_blobs))
				return false;
		}

		boolean this_present_language = true && this.isSetLanguage();
		boolean that_present_language = true && that.isSetLanguage();
		if (this_present_language || that_present_language) {
			if (!(this_present_language && that_present_language))
				return false;
			if (!this.language.equals(that.language))
				return false;
		}

		return true;
	}

	@Override
	public int hashCode() {
		return 0;
	}

	@Override
	public int compareTo(ContentItem other) {
		if (!getClass().equals(other.getClass())) {
			return getClass().getName().compareTo(other.getClass().getName());
		}

		int lastComparison = 0;

		lastComparison = Boolean.valueOf(isSetRaw()).compareTo(other.isSetRaw());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetRaw()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.raw, other.raw);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetEncoding()).compareTo(other.isSetEncoding());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetEncoding()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.encoding, other.encoding);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetMedia_type()).compareTo(other.isSetMedia_type());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetMedia_type()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.media_type, other.media_type);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetClean_html()).compareTo(other.isSetClean_html());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetClean_html()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.clean_html, other.clean_html);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetClean_visible()).compareTo(other.isSetClean_visible());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetClean_visible()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.clean_visible, other.clean_visible);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetLogs()).compareTo(other.isSetLogs());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetLogs()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.logs, other.logs);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetTaggings()).compareTo(other.isSetTaggings());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetTaggings()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.taggings, other.taggings);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetLabels()).compareTo(other.isSetLabels());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetLabels()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.labels, other.labels);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetSentences()).compareTo(other.isSetSentences());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetSentences()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sentences, other.sentences);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetSentence_blobs()).compareTo(other.isSetSentence_blobs());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetSentence_blobs()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sentence_blobs, other.sentence_blobs);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetLanguage()).compareTo(other.isSetLanguage());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetLanguage()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.language, other.language);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		return 0;
	}

	@Override
	public _Fields fieldForId(int fieldId) {
		return _Fields.findByThriftId(fieldId);
	}

	@Override
	public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
		schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
	}

	@Override
	public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
		schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder("ContentItem(");
		boolean first = true;

		if (isSetRaw()) {
			sb.append("raw:");
			if (this.raw == null) {
				sb.append("null");
			} else {
				org.apache.thrift.TBaseHelper.toString(this.raw, sb);
			}
			first = false;
		}
		if (isSetEncoding()) {
			if (!first)
				sb.append(", ");
			sb.append("encoding:");
			if (this.encoding == null) {
				sb.append("null");
			} else {
				sb.append(this.encoding);
			}
			first = false;
		}
		if (isSetMedia_type()) {
			if (!first)
				sb.append(", ");
			sb.append("media_type:");
			if (this.media_type == null) {
				sb.append("null");
			} else {
				sb.append(this.media_type);
			}
			first = false;
		}
		if (isSetClean_html()) {
			if (!first)
				sb.append(", ");
			sb.append("clean_html:");
			if (this.clean_html == null) {
				sb.append("null");
			} else {
				sb.append(this.clean_html);
			}
			first = false;
		}
		if (isSetClean_visible()) {
			if (!first)
				sb.append(", ");
			sb.append("clean_visible:");
			if (this.clean_visible == null) {
				sb.append("null");
			} else {
				sb.append(this.clean_visible);
			}
			first = false;
		}
		if (isSetLogs()) {
			if (!first)
				sb.append(", ");
			sb.append("logs:");
			if (this.logs == null) {
				sb.append("null");
			} else {
				sb.append(this.logs);
			}
			first = false;
		}
		if (isSetTaggings()) {
			if (!first)
				sb.append(", ");
			sb.append("taggings:");
			if (this.taggings == null) {
				sb.append("null");
			} else {
				sb.append(this.taggings);
			}
			first = false;
		}
		if (isSetLabels()) {
			if (!first)
				sb.append(", ");
			sb.append("labels:");
			if (this.labels == null) {
				sb.append("null");
			} else {
				sb.append(this.labels);
			}
			first = false;
		}
		if (isSetSentences()) {
			if (!first)
				sb.append(", ");
			sb.append("sentences:");
			if (this.sentences == null) {
				sb.append("null");
			} else {
				sb.append(this.sentences);
			}
			first = false;
		}
		if (isSetSentence_blobs()) {
			if (!first)
				sb.append(", ");
			sb.append("sentence_blobs:");
			if (this.sentence_blobs == null) {
				sb.append("null");
			} else {
				sb.append(this.sentence_blobs);
			}
			first = false;
		}
		if (isSetLanguage()) {
			if (!first)
				sb.append(", ");
			sb.append("language:");
			if (this.language == null) {
				sb.append("null");
			} else {
				sb.append(this.language);
			}
			first = false;
		}
		sb.append(")");
		return sb.toString();
	}

	public void validate() throws org.apache.thrift.TException {
		// check for required fields
		// check for sub-struct validity
		if (language != null) {
			language.validate();
		}
	}

	private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
		try {
			write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
		} catch (org.apache.thrift.TException te) {
			throw new java.io.IOException(te);
		}
	}

	private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
		try {
			read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
		} catch (org.apache.thrift.TException te) {
			throw new java.io.IOException(te);
		}
	}

	private static class ContentItemStandardSchemeFactory implements SchemeFactory {
		@Override
		public ContentItemStandardScheme getScheme() {
			return new ContentItemStandardScheme();
		}
	}

	private static class ContentItemStandardScheme extends StandardScheme<ContentItem> {

		@Override
		public void read(org.apache.thrift.protocol.TProtocol iprot, ContentItem struct)
				throws org.apache.thrift.TException {
			org.apache.thrift.protocol.TField schemeField;
			iprot.readStructBegin();
			while (true) {
				schemeField = iprot.readFieldBegin();
				if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
					break;
				}
				switch (schemeField.id) {
				case 1: // RAW
					if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						struct.raw = iprot.readBinary();
						struct.setRawIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 2: // ENCODING
					if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						struct.encoding = iprot.readString();
						struct.setEncodingIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 3: // MEDIA_TYPE
					if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						struct.media_type = iprot.readString();
						struct.setMedia_typeIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 4: // CLEAN_HTML
					if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						struct.clean_html = iprot.readString();
						struct.setClean_htmlIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 5: // CLEAN_VISIBLE
					if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						struct.clean_visible = iprot.readString();
						struct.setClean_visibleIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 6: // LOGS
					if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
						{
							org.apache.thrift.protocol.TList _list64 = iprot.readListBegin();
							struct.logs = new ArrayList<String>(_list64.size);
							for (int _i65 = 0; _i65 < _list64.size; ++_i65) {
								String _elem66;
								_elem66 = iprot.readString();
								struct.logs.add(_elem66);
							}
							iprot.readListEnd();
						}
						struct.setLogsIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 7: // TAGGINGS
					if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
						{
							org.apache.thrift.protocol.TMap _map67 = iprot.readMapBegin();
							struct.taggings = new HashMap<String, Tagging>(2 * _map67.size);
							for (int _i68 = 0; _i68 < _map67.size; ++_i68) {
								String _key69;
								Tagging _val70;
								_key69 = iprot.readString();
								_val70 = new Tagging();
								_val70.read(iprot);
								struct.taggings.put(_key69, _val70);
							}
							iprot.readMapEnd();
						}
						struct.setTaggingsIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 8: // LABELS
					if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
						{
							org.apache.thrift.protocol.TMap _map71 = iprot.readMapBegin();
							struct.labels = new HashMap<String, List<Label>>(2 * _map71.size);
							for (int _i72 = 0; _i72 < _map71.size; ++_i72) {
								String _key73;
								List<Label> _val74;
								_key73 = iprot.readString();
								{
									org.apache.thrift.protocol.TList _list75 = iprot.readListBegin();
									_val74 = new ArrayList<Label>(_list75.size);
									for (int _i76 = 0; _i76 < _list75.size; ++_i76) {
										Label _elem77;
										_elem77 = new Label();
										_elem77.read(iprot);
										_val74.add(_elem77);
									}
									iprot.readListEnd();
								}
								struct.labels.put(_key73, _val74);
							}
							iprot.readMapEnd();
						}
						struct.setLabelsIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 9: // SENTENCES
					if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
						{
							org.apache.thrift.protocol.TMap _map78 = iprot.readMapBegin();
							struct.sentences = new HashMap<String, List<Sentence>>(2 * _map78.size);
							for (int _i79 = 0; _i79 < _map78.size; ++_i79) {
								String _key80;
								List<Sentence> _val81;
								_key80 = iprot.readString();
								{
									org.apache.thrift.protocol.TList _list82 = iprot.readListBegin();
									_val81 = new ArrayList<Sentence>(_list82.size);
									for (int _i83 = 0; _i83 < _list82.size; ++_i83) {
										Sentence _elem84;
										_elem84 = new Sentence();
										_elem84.read(iprot);
										_val81.add(_elem84);
									}
									iprot.readListEnd();
								}
								struct.sentences.put(_key80, _val81);
							}
							iprot.readMapEnd();
						}
						struct.setSentencesIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 10: // SENTENCE_BLOBS
					if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
						{
							org.apache.thrift.protocol.TMap _map85 = iprot.readMapBegin();
							struct.sentence_blobs = new HashMap<String, ByteBuffer>(2 * _map85.size);
							for (int _i86 = 0; _i86 < _map85.size; ++_i86) {
								String _key87;
								ByteBuffer _val88;
								_key87 = iprot.readString();
								_val88 = iprot.readBinary();
								struct.sentence_blobs.put(_key87, _val88);
							}
							iprot.readMapEnd();
						}
						struct.setSentence_blobsIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 11: // LANGUAGE
					if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
						struct.language = new Language();
						struct.language.read(iprot);
						struct.setLanguageIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				default:
					org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be checked in the validate method
			struct.validate();
		}

		@Override
		public void write(org.apache.thrift.protocol.TProtocol oprot, ContentItem struct)
				throws org.apache.thrift.TException {
			struct.validate();

			oprot.writeStructBegin(STRUCT_DESC);
			if (struct.raw != null) {
				if (struct.isSetRaw()) {
					oprot.writeFieldBegin(RAW_FIELD_DESC);
					oprot.writeBinary(struct.raw);
					oprot.writeFieldEnd();
				}
			}
			if (struct.encoding != null) {
				if (struct.isSetEncoding()) {
					oprot.writeFieldBegin(ENCODING_FIELD_DESC);
					oprot.writeString(struct.encoding);
					oprot.writeFieldEnd();
				}
			}
			if (struct.media_type != null) {
				if (struct.isSetMedia_type()) {
					oprot.writeFieldBegin(MEDIA_TYPE_FIELD_DESC);
					oprot.writeString(struct.media_type);
					oprot.writeFieldEnd();
				}
			}
			if (struct.clean_html != null) {
				if (struct.isSetClean_html()) {
					oprot.writeFieldBegin(CLEAN_HTML_FIELD_DESC);
					oprot.writeString(struct.clean_html);
					oprot.writeFieldEnd();
				}
			}
			if (struct.clean_visible != null) {
				if (struct.isSetClean_visible()) {
					oprot.writeFieldBegin(CLEAN_VISIBLE_FIELD_DESC);
					oprot.writeString(struct.clean_visible);
					oprot.writeFieldEnd();
				}
			}
			if (struct.logs != null) {
				if (struct.isSetLogs()) {
					oprot.writeFieldBegin(LOGS_FIELD_DESC);
					{
						oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING,
								struct.logs.size()));
						for (String _iter89 : struct.logs) {
							oprot.writeString(_iter89);
						}
						oprot.writeListEnd();
					}
					oprot.writeFieldEnd();
				}
			}
			if (struct.taggings != null) {
				if (struct.isSetTaggings()) {
					oprot.writeFieldBegin(TAGGINGS_FIELD_DESC);
					{
						oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING,
								org.apache.thrift.protocol.TType.STRUCT, struct.taggings.size()));
						for (Map.Entry<String, Tagging> _iter90 : struct.taggings.entrySet()) {
							oprot.writeString(_iter90.getKey());
							_iter90.getValue().write(oprot);
						}
						oprot.writeMapEnd();
					}
					oprot.writeFieldEnd();
				}
			}
			if (struct.labels != null) {
				if (struct.isSetLabels()) {
					oprot.writeFieldBegin(LABELS_FIELD_DESC);
					{
						oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING,
								org.apache.thrift.protocol.TType.LIST, struct.labels.size()));
						for (Map.Entry<String, List<Label>> _iter91 : struct.labels.entrySet()) {
							oprot.writeString(_iter91.getKey());
							{
								oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT,
										_iter91.getValue().size()));
								for (Label _iter92 : _iter91.getValue()) {
									_iter92.write(oprot);
								}
								oprot.writeListEnd();
							}
						}
						oprot.writeMapEnd();
					}
					oprot.writeFieldEnd();
				}
			}
			if (struct.sentences != null) {
				if (struct.isSetSentences()) {
					oprot.writeFieldBegin(SENTENCES_FIELD_DESC);
					{
						oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING,
								org.apache.thrift.protocol.TType.LIST, struct.sentences.size()));
						for (Map.Entry<String, List<Sentence>> _iter93 : struct.sentences.entrySet()) {
							oprot.writeString(_iter93.getKey());
							{
								oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT,
										_iter93.getValue().size()));
								for (Sentence _iter94 : _iter93.getValue()) {
									_iter94.write(oprot);
								}
								oprot.writeListEnd();
							}
						}
						oprot.writeMapEnd();
					}
					oprot.writeFieldEnd();
				}
			}
			if (struct.sentence_blobs != null) {
				if (struct.isSetSentence_blobs()) {
					oprot.writeFieldBegin(SENTENCE_BLOBS_FIELD_DESC);
					{
						oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING,
								org.apache.thrift.protocol.TType.STRING, struct.sentence_blobs.size()));
						for (Map.Entry<String, ByteBuffer> _iter95 : struct.sentence_blobs.entrySet()) {
							oprot.writeString(_iter95.getKey());
							oprot.writeBinary(_iter95.getValue());
						}
						oprot.writeMapEnd();
					}
					oprot.writeFieldEnd();
				}
			}
			if (struct.language != null) {
				if (struct.isSetLanguage()) {
					oprot.writeFieldBegin(LANGUAGE_FIELD_DESC);
					struct.language.write(oprot);
					oprot.writeFieldEnd();
				}
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

	}

	private static class ContentItemTupleSchemeFactory implements SchemeFactory {
		@Override
		public ContentItemTupleScheme getScheme() {
			return new ContentItemTupleScheme();
		}
	}

	private static class ContentItemTupleScheme extends TupleScheme<ContentItem> {

		@Override
		public void write(org.apache.thrift.protocol.TProtocol prot, ContentItem struct)
				throws org.apache.thrift.TException {
			TTupleProtocol oprot = (TTupleProtocol) prot;
			BitSet optionals = new BitSet();
			if (struct.isSetRaw()) {
				optionals.set(0);
			}
			if (struct.isSetEncoding()) {
				optionals.set(1);
			}
			if (struct.isSetMedia_type()) {
				optionals.set(2);
			}
			if (struct.isSetClean_html()) {
				optionals.set(3);
			}
			if (struct.isSetClean_visible()) {
				optionals.set(4);
			}
			if (struct.isSetLogs()) {
				optionals.set(5);
			}
			if (struct.isSetTaggings()) {
				optionals.set(6);
			}
			if (struct.isSetLabels()) {
				optionals.set(7);
			}
			if (struct.isSetSentences()) {
				optionals.set(8);
			}
			if (struct.isSetSentence_blobs()) {
				optionals.set(9);
			}
			if (struct.isSetLanguage()) {
				optionals.set(10);
			}
			oprot.writeBitSet(optionals, 11);
			if (struct.isSetRaw()) {
				oprot.writeBinary(struct.raw);
			}
			if (struct.isSetEncoding()) {
				oprot.writeString(struct.encoding);
			}
			if (struct.isSetMedia_type()) {
				oprot.writeString(struct.media_type);
			}
			if (struct.isSetClean_html()) {
				oprot.writeString(struct.clean_html);
			}
			if (struct.isSetClean_visible()) {
				oprot.writeString(struct.clean_visible);
			}
			if (struct.isSetLogs()) {
				{
					oprot.writeI32(struct.logs.size());
					for (String _iter96 : struct.logs) {
						oprot.writeString(_iter96);
					}
				}
			}
			if (struct.isSetTaggings()) {
				{
					oprot.writeI32(struct.taggings.size());
					for (Map.Entry<String, Tagging> _iter97 : struct.taggings.entrySet()) {
						oprot.writeString(_iter97.getKey());
						_iter97.getValue().write(oprot);
					}
				}
			}
			if (struct.isSetLabels()) {
				{
					oprot.writeI32(struct.labels.size());
					for (Map.Entry<String, List<Label>> _iter98 : struct.labels.entrySet()) {
						oprot.writeString(_iter98.getKey());
						{
							oprot.writeI32(_iter98.getValue().size());
							for (Label _iter99 : _iter98.getValue()) {
								_iter99.write(oprot);
							}
						}
					}
				}
			}
			if (struct.isSetSentences()) {
				{
					oprot.writeI32(struct.sentences.size());
					for (Map.Entry<String, List<Sentence>> _iter100 : struct.sentences.entrySet()) {
						oprot.writeString(_iter100.getKey());
						{
							oprot.writeI32(_iter100.getValue().size());
							for (Sentence _iter101 : _iter100.getValue()) {
								_iter101.write(oprot);
							}
						}
					}
				}
			}
			if (struct.isSetSentence_blobs()) {
				{
					oprot.writeI32(struct.sentence_blobs.size());
					for (Map.Entry<String, ByteBuffer> _iter102 : struct.sentence_blobs.entrySet()) {
						oprot.writeString(_iter102.getKey());
						oprot.writeBinary(_iter102.getValue());
					}
				}
			}
			if (struct.isSetLanguage()) {
				struct.language.write(oprot);
			}
		}

		@Override
		public void read(org.apache.thrift.protocol.TProtocol prot, ContentItem struct) throws org.apache.thrift.TException {
			TTupleProtocol iprot = (TTupleProtocol) prot;
			BitSet incoming = iprot.readBitSet(11);
			if (incoming.get(0)) {
				struct.raw = iprot.readBinary();
				struct.setRawIsSet(true);
			}
			if (incoming.get(1)) {
				struct.encoding = iprot.readString();
				struct.setEncodingIsSet(true);
			}
			if (incoming.get(2)) {
				struct.media_type = iprot.readString();
				struct.setMedia_typeIsSet(true);
			}
			if (incoming.get(3)) {
				struct.clean_html = iprot.readString();
				struct.setClean_htmlIsSet(true);
			}
			if (incoming.get(4)) {
				struct.clean_visible = iprot.readString();
				struct.setClean_visibleIsSet(true);
			}
			if (incoming.get(5)) {
				{
					org.apache.thrift.protocol.TList _list103 = new org.apache.thrift.protocol.TList(
							org.apache.thrift.protocol.TType.STRING, iprot.readI32());
					struct.logs = new ArrayList<String>(_list103.size);
					for (int _i104 = 0; _i104 < _list103.size; ++_i104) {
						String _elem105;
						_elem105 = iprot.readString();
						struct.logs.add(_elem105);
					}
				}
				struct.setLogsIsSet(true);
			}
			if (incoming.get(6)) {
				{
					org.apache.thrift.protocol.TMap _map106 = new org.apache.thrift.protocol.TMap(
							org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
					struct.taggings = new HashMap<String, Tagging>(2 * _map106.size);
					for (int _i107 = 0; _i107 < _map106.size; ++_i107) {
						String _key108;
						Tagging _val109;
						_key108 = iprot.readString();
						_val109 = new Tagging();
						_val109.read(iprot);
						struct.taggings.put(_key108, _val109);
					}
				}
				struct.setTaggingsIsSet(true);
			}
			if (incoming.get(7)) {
				{
					org.apache.thrift.protocol.TMap _map110 = new org.apache.thrift.protocol.TMap(
							org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.LIST, iprot.readI32());
					struct.labels = new HashMap<String, List<Label>>(2 * _map110.size);
					for (int _i111 = 0; _i111 < _map110.size; ++_i111) {
						String _key112;
						List<Label> _val113;
						_key112 = iprot.readString();
						{
							org.apache.thrift.protocol.TList _list114 = new org.apache.thrift.protocol.TList(
									org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
							_val113 = new ArrayList<Label>(_list114.size);
							for (int _i115 = 0; _i115 < _list114.size; ++_i115) {
								Label _elem116;
								_elem116 = new Label();
								_elem116.read(iprot);
								_val113.add(_elem116);
							}
						}
						struct.labels.put(_key112, _val113);
					}
				}
				struct.setLabelsIsSet(true);
			}
			if (incoming.get(8)) {
				{
					org.apache.thrift.protocol.TMap _map117 = new org.apache.thrift.protocol.TMap(
							org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.LIST, iprot.readI32());
					struct.sentences = new HashMap<String, List<Sentence>>(2 * _map117.size);
					for (int _i118 = 0; _i118 < _map117.size; ++_i118) {
						String _key119;
						List<Sentence> _val120;
						_key119 = iprot.readString();
						{
							org.apache.thrift.protocol.TList _list121 = new org.apache.thrift.protocol.TList(
									org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
							_val120 = new ArrayList<Sentence>(_list121.size);
							for (int _i122 = 0; _i122 < _list121.size; ++_i122) {
								Sentence _elem123;
								_elem123 = new Sentence();
								_elem123.read(iprot);
								_val120.add(_elem123);
							}
						}
						struct.sentences.put(_key119, _val120);
					}
				}
				struct.setSentencesIsSet(true);
			}
			if (incoming.get(9)) {
				{
					org.apache.thrift.protocol.TMap _map124 = new org.apache.thrift.protocol.TMap(
							org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, iprot.readI32());
					struct.sentence_blobs = new HashMap<String, ByteBuffer>(2 * _map124.size);
					for (int _i125 = 0; _i125 < _map124.size; ++_i125) {
						String _key126;
						ByteBuffer _val127;
						_key126 = iprot.readString();
						_val127 = iprot.readBinary();
						struct.sentence_blobs.put(_key126, _val127);
					}
				}
				struct.setSentence_blobsIsSet(true);
			}
			if (incoming.get(10)) {
				struct.language = new Language();
				struct.language.read(iprot);
				struct.setLanguageIsSet(true);
			}
		}
	}

}
