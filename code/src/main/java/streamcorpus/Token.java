/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package streamcorpus;

import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.EncodingUtils;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;

/**
 * Textual tokens identified by an NLP pipeline and marked up with metadata from automatic taggers
 * and possibly also Labels from humans.
 */
public class Token implements org.apache.thrift.TBase<Token, Token._Fields>, java.io.Serializable, Cloneable,
		Comparable<Token> {
	private static final org.apache.thrift.protocol.TStruct						STRUCT_DESC									= new org.apache.thrift.protocol.TStruct(
																																																		"Token");

	private static final org.apache.thrift.protocol.TField						TOKEN_NUM_FIELD_DESC				= new org.apache.thrift.protocol.TField(
																																																		"token_num",
																																																		org.apache.thrift.protocol.TType.I32,
																																																		(short) 1);
	private static final org.apache.thrift.protocol.TField						TOKEN_FIELD_DESC						= new org.apache.thrift.protocol.TField(
																																																		"token",
																																																		org.apache.thrift.protocol.TType.STRING,
																																																		(short) 2);
	private static final org.apache.thrift.protocol.TField						OFFSETS_FIELD_DESC					= new org.apache.thrift.protocol.TField(
																																																		"offsets",
																																																		org.apache.thrift.protocol.TType.MAP,
																																																		(short) 3);
	private static final org.apache.thrift.protocol.TField						SENTENCE_POS_FIELD_DESC			= new org.apache.thrift.protocol.TField(
																																																		"sentence_pos",
																																																		org.apache.thrift.protocol.TType.I32,
																																																		(short) 4);
	private static final org.apache.thrift.protocol.TField						LEMMA_FIELD_DESC						= new org.apache.thrift.protocol.TField(
																																																		"lemma",
																																																		org.apache.thrift.protocol.TType.STRING,
																																																		(short) 5);
	private static final org.apache.thrift.protocol.TField						POS_FIELD_DESC							= new org.apache.thrift.protocol.TField(
																																																		"pos",
																																																		org.apache.thrift.protocol.TType.STRING,
																																																		(short) 6);
	private static final org.apache.thrift.protocol.TField						ENTITY_TYPE_FIELD_DESC			= new org.apache.thrift.protocol.TField(
																																																		"entity_type",
																																																		org.apache.thrift.protocol.TType.I32,
																																																		(short) 7);
	private static final org.apache.thrift.protocol.TField						MENTION_ID_FIELD_DESC				= new org.apache.thrift.protocol.TField(
																																																		"mention_id",
																																																		org.apache.thrift.protocol.TType.I16,
																																																		(short) 8);
	private static final org.apache.thrift.protocol.TField						EQUIV_ID_FIELD_DESC					= new org.apache.thrift.protocol.TField(
																																																		"equiv_id",
																																																		org.apache.thrift.protocol.TType.I32,
																																																		(short) 9);
	private static final org.apache.thrift.protocol.TField						PARENT_ID_FIELD_DESC				= new org.apache.thrift.protocol.TField(
																																																		"parent_id",
																																																		org.apache.thrift.protocol.TType.I32,
																																																		(short) 10);
	private static final org.apache.thrift.protocol.TField						DEPENDENCY_PATH_FIELD_DESC	= new org.apache.thrift.protocol.TField(
																																																		"dependency_path",
																																																		org.apache.thrift.protocol.TType.STRING,
																																																		(short) 11);
	private static final org.apache.thrift.protocol.TField						LABELS_FIELD_DESC						= new org.apache.thrift.protocol.TField(
																																																		"labels",
																																																		org.apache.thrift.protocol.TType.MAP,
																																																		(short) 12);

	private static final Map<Class<? extends IScheme>, SchemeFactory>	schemes											= new HashMap<Class<? extends IScheme>, SchemeFactory>();
	static {
		schemes.put(StandardScheme.class, new TokenStandardSchemeFactory());
		schemes.put(TupleScheme.class, new TokenTupleSchemeFactory());
	}

	/**
	 * zero-based index into the stream of tokens from a document
	 */
	public int																												token_num;																																						// required
	/**
	 * actual token string, must always be a UTF8 encoded string, not a unicode string, because thrift
	 * stores them as 8-bit.
	 */
	public String																											token;																																								// required
	/**
	 * offsets into the original data (see Offset.content_form)
	 */
	public Map<OffsetType, Offset>																		offsets;																																							// optional
	/**
	 * zero-based index into the sentence, which is used for dependency parsed data
	 */
	public int																												sentence_pos;																																				// optional
	/**
	 * lemmatization of the token, again must be UTF8
	 */
	public String																											lemma;																																								// optional
	/**
	 * part of speech labels defined by Penn TreeBank:
	 * http://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html Should probably
	 * convert this to an enum, analogous to EntityType
	 */
	public String																											pos;																																									// optional
	/**
	 * entity type from named entity recognizer (classifier)
	 * 
	 * @see EntityType
	 */
	public EntityType																									entity_type;																																					// optional
	/**
	 * Identifier for a multi-token mention starts at zero for each sentence, because we assume
	 * mentions cannot cross sentence boundaries. Really only needed when the entity_type and equiv_id
	 * do not change between tokens that are part of separate mentions, e.g. "The senator is known to
	 * his friends as David, Davy, Zeus, and Mr. Elephant."
	 */
	public short																											mention_id;																																					// optional
	/**
	 * Within-doc coref chain ID. That is, identifier of equivalence class of co-referent tokens.
	 * Default is -1, meaning None.
	 */
	public int																												equiv_id;																																						// optional
	/**
	 * parent sentence_pos in dependency parse. Default is -1, ie None
	 */
	public int																												parent_id;																																						// optional
	/**
	 * grammatical relation label on path to parent in dependency parse, defined by whatever tagger
	 * was used -- should pick a canonical definition here and convert it to an enum.
	 */
	public String																											dependency_path;																																			// optional
	/**
	 * Labels attached to this token, defaults to an empty map
	 */
	public Map<String, List<Label>>																		labels;																																							// optional

	/**
	 * The set of fields this struct contains, along with convenience methods for finding and
	 * manipulating them.
	 */
	public enum _Fields implements org.apache.thrift.TFieldIdEnum {
		/**
		 * zero-based index into the stream of tokens from a document
		 */
		TOKEN_NUM((short) 1, "token_num"),
		/**
		 * actual token string, must always be a UTF8 encoded string, not a unicode string, because
		 * thrift stores them as 8-bit.
		 */
		TOKEN((short) 2, "token"),
		/**
		 * offsets into the original data (see Offset.content_form)
		 */
		OFFSETS((short) 3, "offsets"),
		/**
		 * zero-based index into the sentence, which is used for dependency parsed data
		 */
		SENTENCE_POS((short) 4, "sentence_pos"),
		/**
		 * lemmatization of the token, again must be UTF8
		 */
		LEMMA((short) 5, "lemma"),
		/**
		 * part of speech labels defined by Penn TreeBank:
		 * http://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html Should probably
		 * convert this to an enum, analogous to EntityType
		 */
		POS((short) 6, "pos"),
		/**
		 * entity type from named entity recognizer (classifier)
		 * 
		 * @see EntityType
		 */
		ENTITY_TYPE((short) 7, "entity_type"),
		/**
		 * Identifier for a multi-token mention starts at zero for each sentence, because we assume
		 * mentions cannot cross sentence boundaries. Really only needed when the entity_type and
		 * equiv_id do not change between tokens that are part of separate mentions, e.g. "The senator
		 * is known to his friends as David, Davy, Zeus, and Mr. Elephant."
		 */
		MENTION_ID((short) 8, "mention_id"),
		/**
		 * Within-doc coref chain ID. That is, identifier of equivalence class of co-referent tokens.
		 * Default is -1, meaning None.
		 */
		EQUIV_ID((short) 9, "equiv_id"),
		/**
		 * parent sentence_pos in dependency parse. Default is -1, ie None
		 */
		PARENT_ID((short) 10, "parent_id"),
		/**
		 * grammatical relation label on path to parent in dependency parse, defined by whatever tagger
		 * was used -- should pick a canonical definition here and convert it to an enum.
		 */
		DEPENDENCY_PATH((short) 11, "dependency_path"),
		/**
		 * Labels attached to this token, defaults to an empty map
		 */
		LABELS((short) 12, "labels");

		private static final Map<String, _Fields>	byName	= new HashMap<String, _Fields>();

		static {
			for (_Fields field : EnumSet.allOf(_Fields.class)) {
				byName.put(field.getFieldName(), field);
			}
		}

		/**
		 * Find the _Fields constant that matches fieldId, or null if its not found.
		 */
		public static _Fields findByThriftId(int fieldId) {
			switch (fieldId) {
			case 1: // TOKEN_NUM
				return TOKEN_NUM;
			case 2: // TOKEN
				return TOKEN;
			case 3: // OFFSETS
				return OFFSETS;
			case 4: // SENTENCE_POS
				return SENTENCE_POS;
			case 5: // LEMMA
				return LEMMA;
			case 6: // POS
				return POS;
			case 7: // ENTITY_TYPE
				return ENTITY_TYPE;
			case 8: // MENTION_ID
				return MENTION_ID;
			case 9: // EQUIV_ID
				return EQUIV_ID;
			case 10: // PARENT_ID
				return PARENT_ID;
			case 11: // DEPENDENCY_PATH
				return DEPENDENCY_PATH;
			case 12: // LABELS
				return LABELS;
			default:
				return null;
			}
		}

		/**
		 * Find the _Fields constant that matches fieldId, throwing an exception if it is not found.
		 */
		public static _Fields findByThriftIdOrThrow(int fieldId) {
			_Fields fields = findByThriftId(fieldId);
			if (fields == null)
				throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
			return fields;
		}

		/**
		 * Find the _Fields constant that matches name, or null if its not found.
		 */
		public static _Fields findByName(String name) {
			return byName.get(name);
		}

		private final short		_thriftId;
		private final String	_fieldName;

		_Fields(short thriftId, String fieldName) {
			_thriftId = thriftId;
			_fieldName = fieldName;
		}

		@Override
		public short getThriftFieldId() {
			return _thriftId;
		}

		@Override
		public String getFieldName() {
			return _fieldName;
		}
	}

	// isset id assignments
	private static final int																										__TOKEN_NUM_ISSET_ID		= 0;
	private static final int																										__SENTENCE_POS_ISSET_ID	= 1;
	private static final int																										__MENTION_ID_ISSET_ID		= 2;
	private static final int																										__EQUIV_ID_ISSET_ID			= 3;
	private static final int																										__PARENT_ID_ISSET_ID		= 4;
	private byte																																__isset_bitfield				= 0;
	private _Fields																															optionals[]							= {
			_Fields.OFFSETS, _Fields.SENTENCE_POS, _Fields.LEMMA, _Fields.POS, _Fields.ENTITY_TYPE, _Fields.MENTION_ID,
			_Fields.EQUIV_ID, _Fields.PARENT_ID, _Fields.DEPENDENCY_PATH, _Fields.LABELS										};
	public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData>	metaDataMap;
	static {
		Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(
				_Fields.class);
		tmpMap.put(_Fields.TOKEN_NUM, new org.apache.thrift.meta_data.FieldMetaData("token_num",
				org.apache.thrift.TFieldRequirementType.DEFAULT, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.I32)));
		tmpMap.put(_Fields.TOKEN, new org.apache.thrift.meta_data.FieldMetaData("token",
				org.apache.thrift.TFieldRequirementType.DEFAULT, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.STRING)));
		tmpMap.put(_Fields.OFFSETS, new org.apache.thrift.meta_data.FieldMetaData("offsets",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.MapMetaData(
						org.apache.thrift.protocol.TType.MAP, new org.apache.thrift.meta_data.EnumMetaData(
								org.apache.thrift.protocol.TType.ENUM, OffsetType.class),
						new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, Offset.class))));
		tmpMap.put(_Fields.SENTENCE_POS, new org.apache.thrift.meta_data.FieldMetaData("sentence_pos",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.I32)));
		tmpMap.put(_Fields.LEMMA, new org.apache.thrift.meta_data.FieldMetaData("lemma",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.STRING)));
		tmpMap.put(_Fields.POS, new org.apache.thrift.meta_data.FieldMetaData("pos",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.STRING)));
		tmpMap.put(_Fields.ENTITY_TYPE, new org.apache.thrift.meta_data.FieldMetaData("entity_type",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.EnumMetaData(
						org.apache.thrift.protocol.TType.ENUM, EntityType.class)));
		tmpMap.put(_Fields.MENTION_ID, new org.apache.thrift.meta_data.FieldMetaData("mention_id",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.I16)));
		tmpMap.put(_Fields.EQUIV_ID, new org.apache.thrift.meta_data.FieldMetaData("equiv_id",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.I32)));
		tmpMap.put(_Fields.PARENT_ID, new org.apache.thrift.meta_data.FieldMetaData("parent_id",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.I32)));
		tmpMap.put(_Fields.DEPENDENCY_PATH, new org.apache.thrift.meta_data.FieldMetaData("dependency_path",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.FieldValueMetaData(
						org.apache.thrift.protocol.TType.STRING)));
		tmpMap.put(_Fields.LABELS, new org.apache.thrift.meta_data.FieldMetaData("labels",
				org.apache.thrift.TFieldRequirementType.OPTIONAL, new org.apache.thrift.meta_data.MapMetaData(
						org.apache.thrift.protocol.TType.MAP, new org.apache.thrift.meta_data.FieldValueMetaData(
								org.apache.thrift.protocol.TType.STRING, "AnnotatorID"), new org.apache.thrift.meta_data.ListMetaData(
								org.apache.thrift.protocol.TType.LIST, new org.apache.thrift.meta_data.StructMetaData(
										org.apache.thrift.protocol.TType.STRUCT, Label.class)))));
		metaDataMap = Collections.unmodifiableMap(tmpMap);
		org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(Token.class, metaDataMap);
	}

	public Token() {
		this.offsets = new HashMap<OffsetType, Offset>();

		this.sentence_pos = -1;

		this.mention_id = (short) -1;

		this.equiv_id = -1;

		this.parent_id = -1;

		this.labels = new HashMap<String, List<Label>>();

	}

	public Token(int token_num, String token) {
		this();
		this.token_num = token_num;
		setToken_numIsSet(true);
		this.token = token;
	}

	/**
	 * Performs a deep copy on <i>other</i>.
	 */
	public Token(Token other) {
		__isset_bitfield = other.__isset_bitfield;
		this.token_num = other.token_num;
		if (other.isSetToken()) {
			this.token = other.token;
		}
		if (other.isSetOffsets()) {
			Map<OffsetType, Offset> __this__offsets = new HashMap<OffsetType, Offset>();
			for (Map.Entry<OffsetType, Offset> other_element : other.offsets.entrySet()) {

				OffsetType other_element_key = other_element.getKey();
				Offset other_element_value = other_element.getValue();

				OffsetType __this__offsets_copy_key = other_element_key;

				Offset __this__offsets_copy_value = new Offset(other_element_value);

				__this__offsets.put(__this__offsets_copy_key, __this__offsets_copy_value);
			}
			this.offsets = __this__offsets;
		}
		this.sentence_pos = other.sentence_pos;
		if (other.isSetLemma()) {
			this.lemma = other.lemma;
		}
		if (other.isSetPos()) {
			this.pos = other.pos;
		}
		if (other.isSetEntity_type()) {
			this.entity_type = other.entity_type;
		}
		this.mention_id = other.mention_id;
		this.equiv_id = other.equiv_id;
		this.parent_id = other.parent_id;
		if (other.isSetDependency_path()) {
			this.dependency_path = other.dependency_path;
		}
		if (other.isSetLabels()) {
			Map<String, List<Label>> __this__labels = new HashMap<String, List<Label>>();
			for (Map.Entry<String, List<Label>> other_element : other.labels.entrySet()) {

				String other_element_key = other_element.getKey();
				List<Label> other_element_value = other_element.getValue();

				String __this__labels_copy_key = other_element_key;

				List<Label> __this__labels_copy_value = new ArrayList<Label>();
				for (Label other_element_value_element : other_element_value) {
					__this__labels_copy_value.add(new Label(other_element_value_element));
				}

				__this__labels.put(__this__labels_copy_key, __this__labels_copy_value);
			}
			this.labels = __this__labels;
		}
	}

	@Override
	public Token deepCopy() {
		return new Token(this);
	}

	@Override
	public void clear() {
		setToken_numIsSet(false);
		this.token_num = 0;
		this.token = null;
		this.offsets = new HashMap<OffsetType, Offset>();

		this.sentence_pos = -1;

		this.lemma = null;
		this.pos = null;
		this.entity_type = null;
		this.mention_id = (short) -1;

		this.equiv_id = -1;

		this.parent_id = -1;

		this.dependency_path = null;
		this.labels = new HashMap<String, List<Label>>();

	}

	/**
	 * zero-based index into the stream of tokens from a document
	 */
	public int getToken_num() {
		return this.token_num;
	}

	/**
	 * zero-based index into the stream of tokens from a document
	 */
	public Token setToken_num(int token_num) {
		this.token_num = token_num;
		setToken_numIsSet(true);
		return this;
	}

	public void unsetToken_num() {
		__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __TOKEN_NUM_ISSET_ID);
	}

	/** Returns true if field token_num is set (has been assigned a value) and false otherwise */
	public boolean isSetToken_num() {
		return EncodingUtils.testBit(__isset_bitfield, __TOKEN_NUM_ISSET_ID);
	}

	public void setToken_numIsSet(boolean value) {
		__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __TOKEN_NUM_ISSET_ID, value);
	}

	/**
	 * actual token string, must always be a UTF8 encoded string, not a unicode string, because thrift
	 * stores them as 8-bit.
	 */
	public String getToken() {
		return this.token;
	}

	/**
	 * actual token string, must always be a UTF8 encoded string, not a unicode string, because thrift
	 * stores them as 8-bit.
	 */
	public Token setToken(String token) {
		this.token = token;
		return this;
	}

	public void unsetToken() {
		this.token = null;
	}

	/** Returns true if field token is set (has been assigned a value) and false otherwise */
	public boolean isSetToken() {
		return this.token != null;
	}

	public void setTokenIsSet(boolean value) {
		if (!value) {
			this.token = null;
		}
	}

	public int getOffsetsSize() {
		return (this.offsets == null) ? 0 : this.offsets.size();
	}

	public void putToOffsets(OffsetType key, Offset val) {
		if (this.offsets == null) {
			this.offsets = new HashMap<OffsetType, Offset>();
		}
		this.offsets.put(key, val);
	}

	/**
	 * offsets into the original data (see Offset.content_form)
	 */
	public Map<OffsetType, Offset> getOffsets() {
		return this.offsets;
	}

	/**
	 * offsets into the original data (see Offset.content_form)
	 */
	public Token setOffsets(Map<OffsetType, Offset> offsets) {
		this.offsets = offsets;
		return this;
	}

	public void unsetOffsets() {
		this.offsets = null;
	}

	/** Returns true if field offsets is set (has been assigned a value) and false otherwise */
	public boolean isSetOffsets() {
		return this.offsets != null;
	}

	public void setOffsetsIsSet(boolean value) {
		if (!value) {
			this.offsets = null;
		}
	}

	/**
	 * zero-based index into the sentence, which is used for dependency parsed data
	 */
	public int getSentence_pos() {
		return this.sentence_pos;
	}

	/**
	 * zero-based index into the sentence, which is used for dependency parsed data
	 */
	public Token setSentence_pos(int sentence_pos) {
		this.sentence_pos = sentence_pos;
		setSentence_posIsSet(true);
		return this;
	}

	public void unsetSentence_pos() {
		__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SENTENCE_POS_ISSET_ID);
	}

	/** Returns true if field sentence_pos is set (has been assigned a value) and false otherwise */
	public boolean isSetSentence_pos() {
		return EncodingUtils.testBit(__isset_bitfield, __SENTENCE_POS_ISSET_ID);
	}

	public void setSentence_posIsSet(boolean value) {
		__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SENTENCE_POS_ISSET_ID, value);
	}

	/**
	 * lemmatization of the token, again must be UTF8
	 */
	public String getLemma() {
		return this.lemma;
	}

	/**
	 * lemmatization of the token, again must be UTF8
	 */
	public Token setLemma(String lemma) {
		this.lemma = lemma;
		return this;
	}

	public void unsetLemma() {
		this.lemma = null;
	}

	/** Returns true if field lemma is set (has been assigned a value) and false otherwise */
	public boolean isSetLemma() {
		return this.lemma != null;
	}

	public void setLemmaIsSet(boolean value) {
		if (!value) {
			this.lemma = null;
		}
	}

	/**
	 * part of speech labels defined by Penn TreeBank:
	 * http://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html Should probably
	 * convert this to an enum, analogous to EntityType
	 */
	public String getPos() {
		return this.pos;
	}

	/**
	 * part of speech labels defined by Penn TreeBank:
	 * http://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html Should probably
	 * convert this to an enum, analogous to EntityType
	 */
	public Token setPos(String pos) {
		this.pos = pos;
		return this;
	}

	public void unsetPos() {
		this.pos = null;
	}

	/** Returns true if field pos is set (has been assigned a value) and false otherwise */
	public boolean isSetPos() {
		return this.pos != null;
	}

	public void setPosIsSet(boolean value) {
		if (!value) {
			this.pos = null;
		}
	}

	/**
	 * entity type from named entity recognizer (classifier)
	 * 
	 * @see EntityType
	 */
	public EntityType getEntity_type() {
		return this.entity_type;
	}

	/**
	 * entity type from named entity recognizer (classifier)
	 * 
	 * @see EntityType
	 */
	public Token setEntity_type(EntityType entity_type) {
		this.entity_type = entity_type;
		return this;
	}

	public void unsetEntity_type() {
		this.entity_type = null;
	}

	/** Returns true if field entity_type is set (has been assigned a value) and false otherwise */
	public boolean isSetEntity_type() {
		return this.entity_type != null;
	}

	public void setEntity_typeIsSet(boolean value) {
		if (!value) {
			this.entity_type = null;
		}
	}

	/**
	 * Identifier for a multi-token mention starts at zero for each sentence, because we assume
	 * mentions cannot cross sentence boundaries. Really only needed when the entity_type and equiv_id
	 * do not change between tokens that are part of separate mentions, e.g. "The senator is known to
	 * his friends as David, Davy, Zeus, and Mr. Elephant."
	 */
	public short getMention_id() {
		return this.mention_id;
	}

	/**
	 * Identifier for a multi-token mention starts at zero for each sentence, because we assume
	 * mentions cannot cross sentence boundaries. Really only needed when the entity_type and equiv_id
	 * do not change between tokens that are part of separate mentions, e.g. "The senator is known to
	 * his friends as David, Davy, Zeus, and Mr. Elephant."
	 */
	public Token setMention_id(short mention_id) {
		this.mention_id = mention_id;
		setMention_idIsSet(true);
		return this;
	}

	public void unsetMention_id() {
		__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MENTION_ID_ISSET_ID);
	}

	/** Returns true if field mention_id is set (has been assigned a value) and false otherwise */
	public boolean isSetMention_id() {
		return EncodingUtils.testBit(__isset_bitfield, __MENTION_ID_ISSET_ID);
	}

	public void setMention_idIsSet(boolean value) {
		__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MENTION_ID_ISSET_ID, value);
	}

	/**
	 * Within-doc coref chain ID. That is, identifier of equivalence class of co-referent tokens.
	 * Default is -1, meaning None.
	 */
	public int getEquiv_id() {
		return this.equiv_id;
	}

	/**
	 * Within-doc coref chain ID. That is, identifier of equivalence class of co-referent tokens.
	 * Default is -1, meaning None.
	 */
	public Token setEquiv_id(int equiv_id) {
		this.equiv_id = equiv_id;
		setEquiv_idIsSet(true);
		return this;
	}

	public void unsetEquiv_id() {
		__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __EQUIV_ID_ISSET_ID);
	}

	/** Returns true if field equiv_id is set (has been assigned a value) and false otherwise */
	public boolean isSetEquiv_id() {
		return EncodingUtils.testBit(__isset_bitfield, __EQUIV_ID_ISSET_ID);
	}

	public void setEquiv_idIsSet(boolean value) {
		__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __EQUIV_ID_ISSET_ID, value);
	}

	/**
	 * parent sentence_pos in dependency parse. Default is -1, ie None
	 */
	public int getParent_id() {
		return this.parent_id;
	}

	/**
	 * parent sentence_pos in dependency parse. Default is -1, ie None
	 */
	public Token setParent_id(int parent_id) {
		this.parent_id = parent_id;
		setParent_idIsSet(true);
		return this;
	}

	public void unsetParent_id() {
		__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __PARENT_ID_ISSET_ID);
	}

	/** Returns true if field parent_id is set (has been assigned a value) and false otherwise */
	public boolean isSetParent_id() {
		return EncodingUtils.testBit(__isset_bitfield, __PARENT_ID_ISSET_ID);
	}

	public void setParent_idIsSet(boolean value) {
		__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __PARENT_ID_ISSET_ID, value);
	}

	/**
	 * grammatical relation label on path to parent in dependency parse, defined by whatever tagger
	 * was used -- should pick a canonical definition here and convert it to an enum.
	 */
	public String getDependency_path() {
		return this.dependency_path;
	}

	/**
	 * grammatical relation label on path to parent in dependency parse, defined by whatever tagger
	 * was used -- should pick a canonical definition here and convert it to an enum.
	 */
	public Token setDependency_path(String dependency_path) {
		this.dependency_path = dependency_path;
		return this;
	}

	public void unsetDependency_path() {
		this.dependency_path = null;
	}

	/** Returns true if field dependency_path is set (has been assigned a value) and false otherwise */
	public boolean isSetDependency_path() {
		return this.dependency_path != null;
	}

	public void setDependency_pathIsSet(boolean value) {
		if (!value) {
			this.dependency_path = null;
		}
	}

	public int getLabelsSize() {
		return (this.labels == null) ? 0 : this.labels.size();
	}

	public void putToLabels(String key, List<Label> val) {
		if (this.labels == null) {
			this.labels = new HashMap<String, List<Label>>();
		}
		this.labels.put(key, val);
	}

	/**
	 * Labels attached to this token, defaults to an empty map
	 */
	public Map<String, List<Label>> getLabels() {
		return this.labels;
	}

	/**
	 * Labels attached to this token, defaults to an empty map
	 */
	public Token setLabels(Map<String, List<Label>> labels) {
		this.labels = labels;
		return this;
	}

	public void unsetLabels() {
		this.labels = null;
	}

	/** Returns true if field labels is set (has been assigned a value) and false otherwise */
	public boolean isSetLabels() {
		return this.labels != null;
	}

	public void setLabelsIsSet(boolean value) {
		if (!value) {
			this.labels = null;
		}
	}

	@Override
	public void setFieldValue(_Fields field, Object value) {
		switch (field) {
		case TOKEN_NUM:
			if (value == null) {
				unsetToken_num();
			} else {
				setToken_num((Integer) value);
			}
			break;

		case TOKEN:
			if (value == null) {
				unsetToken();
			} else {
				setToken((String) value);
			}
			break;

		case OFFSETS:
			if (value == null) {
				unsetOffsets();
			} else {
				setOffsets((Map<OffsetType, Offset>) value);
			}
			break;

		case SENTENCE_POS:
			if (value == null) {
				unsetSentence_pos();
			} else {
				setSentence_pos((Integer) value);
			}
			break;

		case LEMMA:
			if (value == null) {
				unsetLemma();
			} else {
				setLemma((String) value);
			}
			break;

		case POS:
			if (value == null) {
				unsetPos();
			} else {
				setPos((String) value);
			}
			break;

		case ENTITY_TYPE:
			if (value == null) {
				unsetEntity_type();
			} else {
				setEntity_type((EntityType) value);
			}
			break;

		case MENTION_ID:
			if (value == null) {
				unsetMention_id();
			} else {
				setMention_id((Short) value);
			}
			break;

		case EQUIV_ID:
			if (value == null) {
				unsetEquiv_id();
			} else {
				setEquiv_id((Integer) value);
			}
			break;

		case PARENT_ID:
			if (value == null) {
				unsetParent_id();
			} else {
				setParent_id((Integer) value);
			}
			break;

		case DEPENDENCY_PATH:
			if (value == null) {
				unsetDependency_path();
			} else {
				setDependency_path((String) value);
			}
			break;

		case LABELS:
			if (value == null) {
				unsetLabels();
			} else {
				setLabels((Map<String, List<Label>>) value);
			}
			break;

		}
	}

	@Override
	public Object getFieldValue(_Fields field) {
		switch (field) {
		case TOKEN_NUM:
			return Integer.valueOf(getToken_num());

		case TOKEN:
			return getToken();

		case OFFSETS:
			return getOffsets();

		case SENTENCE_POS:
			return Integer.valueOf(getSentence_pos());

		case LEMMA:
			return getLemma();

		case POS:
			return getPos();

		case ENTITY_TYPE:
			return getEntity_type();

		case MENTION_ID:
			return Short.valueOf(getMention_id());

		case EQUIV_ID:
			return Integer.valueOf(getEquiv_id());

		case PARENT_ID:
			return Integer.valueOf(getParent_id());

		case DEPENDENCY_PATH:
			return getDependency_path();

		case LABELS:
			return getLabels();

		}
		throw new IllegalStateException();
	}

	/**
	 * Returns true if field corresponding to fieldID is set (has been assigned a value) and false
	 * otherwise
	 */
	@Override
	public boolean isSet(_Fields field) {
		if (field == null) {
			throw new IllegalArgumentException();
		}

		switch (field) {
		case TOKEN_NUM:
			return isSetToken_num();
		case TOKEN:
			return isSetToken();
		case OFFSETS:
			return isSetOffsets();
		case SENTENCE_POS:
			return isSetSentence_pos();
		case LEMMA:
			return isSetLemma();
		case POS:
			return isSetPos();
		case ENTITY_TYPE:
			return isSetEntity_type();
		case MENTION_ID:
			return isSetMention_id();
		case EQUIV_ID:
			return isSetEquiv_id();
		case PARENT_ID:
			return isSetParent_id();
		case DEPENDENCY_PATH:
			return isSetDependency_path();
		case LABELS:
			return isSetLabels();
		}
		throw new IllegalStateException();
	}

	@Override
	public boolean equals(Object that) {
		if (that == null)
			return false;
		if (that instanceof Token)
			return this.equals((Token) that);
		return false;
	}

	public boolean equals(Token that) {
		if (that == null)
			return false;

		boolean this_present_token_num = true;
		boolean that_present_token_num = true;
		if (this_present_token_num || that_present_token_num) {
			if (!(this_present_token_num && that_present_token_num))
				return false;
			if (this.token_num != that.token_num)
				return false;
		}

		boolean this_present_token = true && this.isSetToken();
		boolean that_present_token = true && that.isSetToken();
		if (this_present_token || that_present_token) {
			if (!(this_present_token && that_present_token))
				return false;
			if (!this.token.equals(that.token))
				return false;
		}

		boolean this_present_offsets = true && this.isSetOffsets();
		boolean that_present_offsets = true && that.isSetOffsets();
		if (this_present_offsets || that_present_offsets) {
			if (!(this_present_offsets && that_present_offsets))
				return false;
			if (!this.offsets.equals(that.offsets))
				return false;
		}

		boolean this_present_sentence_pos = true && this.isSetSentence_pos();
		boolean that_present_sentence_pos = true && that.isSetSentence_pos();
		if (this_present_sentence_pos || that_present_sentence_pos) {
			if (!(this_present_sentence_pos && that_present_sentence_pos))
				return false;
			if (this.sentence_pos != that.sentence_pos)
				return false;
		}

		boolean this_present_lemma = true && this.isSetLemma();
		boolean that_present_lemma = true && that.isSetLemma();
		if (this_present_lemma || that_present_lemma) {
			if (!(this_present_lemma && that_present_lemma))
				return false;
			if (!this.lemma.equals(that.lemma))
				return false;
		}

		boolean this_present_pos = true && this.isSetPos();
		boolean that_present_pos = true && that.isSetPos();
		if (this_present_pos || that_present_pos) {
			if (!(this_present_pos && that_present_pos))
				return false;
			if (!this.pos.equals(that.pos))
				return false;
		}

		boolean this_present_entity_type = true && this.isSetEntity_type();
		boolean that_present_entity_type = true && that.isSetEntity_type();
		if (this_present_entity_type || that_present_entity_type) {
			if (!(this_present_entity_type && that_present_entity_type))
				return false;
			if (!this.entity_type.equals(that.entity_type))
				return false;
		}

		boolean this_present_mention_id = true && this.isSetMention_id();
		boolean that_present_mention_id = true && that.isSetMention_id();
		if (this_present_mention_id || that_present_mention_id) {
			if (!(this_present_mention_id && that_present_mention_id))
				return false;
			if (this.mention_id != that.mention_id)
				return false;
		}

		boolean this_present_equiv_id = true && this.isSetEquiv_id();
		boolean that_present_equiv_id = true && that.isSetEquiv_id();
		if (this_present_equiv_id || that_present_equiv_id) {
			if (!(this_present_equiv_id && that_present_equiv_id))
				return false;
			if (this.equiv_id != that.equiv_id)
				return false;
		}

		boolean this_present_parent_id = true && this.isSetParent_id();
		boolean that_present_parent_id = true && that.isSetParent_id();
		if (this_present_parent_id || that_present_parent_id) {
			if (!(this_present_parent_id && that_present_parent_id))
				return false;
			if (this.parent_id != that.parent_id)
				return false;
		}

		boolean this_present_dependency_path = true && this.isSetDependency_path();
		boolean that_present_dependency_path = true && that.isSetDependency_path();
		if (this_present_dependency_path || that_present_dependency_path) {
			if (!(this_present_dependency_path && that_present_dependency_path))
				return false;
			if (!this.dependency_path.equals(that.dependency_path))
				return false;
		}

		boolean this_present_labels = true && this.isSetLabels();
		boolean that_present_labels = true && that.isSetLabels();
		if (this_present_labels || that_present_labels) {
			if (!(this_present_labels && that_present_labels))
				return false;
			if (!this.labels.equals(that.labels))
				return false;
		}

		return true;
	}

	@Override
	public int hashCode() {
		return 0;
	}

	@Override
	public int compareTo(Token other) {
		if (!getClass().equals(other.getClass())) {
			return getClass().getName().compareTo(other.getClass().getName());
		}

		int lastComparison = 0;

		lastComparison = Boolean.valueOf(isSetToken_num()).compareTo(other.isSetToken_num());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetToken_num()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.token_num, other.token_num);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetToken()).compareTo(other.isSetToken());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetToken()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.token, other.token);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetOffsets()).compareTo(other.isSetOffsets());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetOffsets()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.offsets, other.offsets);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetSentence_pos()).compareTo(other.isSetSentence_pos());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetSentence_pos()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.sentence_pos, other.sentence_pos);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetLemma()).compareTo(other.isSetLemma());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetLemma()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.lemma, other.lemma);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetPos()).compareTo(other.isSetPos());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetPos()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.pos, other.pos);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetEntity_type()).compareTo(other.isSetEntity_type());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetEntity_type()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.entity_type, other.entity_type);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetMention_id()).compareTo(other.isSetMention_id());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetMention_id()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.mention_id, other.mention_id);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetEquiv_id()).compareTo(other.isSetEquiv_id());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetEquiv_id()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.equiv_id, other.equiv_id);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetParent_id()).compareTo(other.isSetParent_id());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetParent_id()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.parent_id, other.parent_id);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetDependency_path()).compareTo(other.isSetDependency_path());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetDependency_path()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.dependency_path, other.dependency_path);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		lastComparison = Boolean.valueOf(isSetLabels()).compareTo(other.isSetLabels());
		if (lastComparison != 0) {
			return lastComparison;
		}
		if (isSetLabels()) {
			lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.labels, other.labels);
			if (lastComparison != 0) {
				return lastComparison;
			}
		}
		return 0;
	}

	@Override
	public _Fields fieldForId(int fieldId) {
		return _Fields.findByThriftId(fieldId);
	}

	@Override
	public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
		schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
	}

	@Override
	public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
		schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder("Token(");
		boolean first = true;

		sb.append("token_num:");
		sb.append(this.token_num);
		first = false;
		if (!first)
			sb.append(", ");
		sb.append("token:");
		if (this.token == null) {
			sb.append("null");
		} else {
			sb.append(this.token);
		}
		first = false;
		if (isSetOffsets()) {
			if (!first)
				sb.append(", ");
			sb.append("offsets:");
			if (this.offsets == null) {
				sb.append("null");
			} else {
				sb.append(this.offsets);
			}
			first = false;
		}
		if (isSetSentence_pos()) {
			if (!first)
				sb.append(", ");
			sb.append("sentence_pos:");
			sb.append(this.sentence_pos);
			first = false;
		}
		if (isSetLemma()) {
			if (!first)
				sb.append(", ");
			sb.append("lemma:");
			if (this.lemma == null) {
				sb.append("null");
			} else {
				sb.append(this.lemma);
			}
			first = false;
		}
		if (isSetPos()) {
			if (!first)
				sb.append(", ");
			sb.append("pos:");
			if (this.pos == null) {
				sb.append("null");
			} else {
				sb.append(this.pos);
			}
			first = false;
		}
		if (isSetEntity_type()) {
			if (!first)
				sb.append(", ");
			sb.append("entity_type:");
			if (this.entity_type == null) {
				sb.append("null");
			} else {
				sb.append(this.entity_type);
			}
			first = false;
		}
		if (isSetMention_id()) {
			if (!first)
				sb.append(", ");
			sb.append("mention_id:");
			sb.append(this.mention_id);
			first = false;
		}
		if (isSetEquiv_id()) {
			if (!first)
				sb.append(", ");
			sb.append("equiv_id:");
			sb.append(this.equiv_id);
			first = false;
		}
		if (isSetParent_id()) {
			if (!first)
				sb.append(", ");
			sb.append("parent_id:");
			sb.append(this.parent_id);
			first = false;
		}
		if (isSetDependency_path()) {
			if (!first)
				sb.append(", ");
			sb.append("dependency_path:");
			if (this.dependency_path == null) {
				sb.append("null");
			} else {
				sb.append(this.dependency_path);
			}
			first = false;
		}
		if (isSetLabels()) {
			if (!first)
				sb.append(", ");
			sb.append("labels:");
			if (this.labels == null) {
				sb.append("null");
			} else {
				sb.append(this.labels);
			}
			first = false;
		}
		sb.append(")");
		return sb.toString();
	}

	public void validate() throws org.apache.thrift.TException {
		// check for required fields
		// check for sub-struct validity
	}

	private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
		try {
			write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
		} catch (org.apache.thrift.TException te) {
			throw new java.io.IOException(te);
		}
	}

	private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
		try {
			// it doesn't seem like you should have to do this, but java serialization is wacky, and
			// doesn't call the default constructor.
			__isset_bitfield = 0;
			read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
		} catch (org.apache.thrift.TException te) {
			throw new java.io.IOException(te);
		}
	}

	private static class TokenStandardSchemeFactory implements SchemeFactory {
		@Override
		public TokenStandardScheme getScheme() {
			return new TokenStandardScheme();
		}
	}

	private static class TokenStandardScheme extends StandardScheme<Token> {

		@Override
		public void read(org.apache.thrift.protocol.TProtocol iprot, Token struct) throws org.apache.thrift.TException {
			org.apache.thrift.protocol.TField schemeField;
			iprot.readStructBegin();
			while (true) {
				schemeField = iprot.readFieldBegin();
				if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
					break;
				}
				switch (schemeField.id) {
				case 1: // TOKEN_NUM
					if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
						struct.token_num = iprot.readI32();
						struct.setToken_numIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 2: // TOKEN
					if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						struct.token = iprot.readString();
						struct.setTokenIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 3: // OFFSETS
					if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
						{
							org.apache.thrift.protocol.TMap _map10 = iprot.readMapBegin();
							struct.offsets = new HashMap<OffsetType, Offset>(2 * _map10.size);
							for (int _i11 = 0; _i11 < _map10.size; ++_i11) {
								OffsetType _key12;
								Offset _val13;
								_key12 = OffsetType.findByValue(iprot.readI32());
								_val13 = new Offset();
								_val13.read(iprot);
								struct.offsets.put(_key12, _val13);
							}
							iprot.readMapEnd();
						}
						struct.setOffsetsIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 4: // SENTENCE_POS
					if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
						struct.sentence_pos = iprot.readI32();
						struct.setSentence_posIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 5: // LEMMA
					if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						struct.lemma = iprot.readString();
						struct.setLemmaIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 6: // POS
					if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						struct.pos = iprot.readString();
						struct.setPosIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 7: // ENTITY_TYPE
					if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
						struct.entity_type = EntityType.findByValue(iprot.readI32());
						struct.setEntity_typeIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 8: // MENTION_ID
					if (schemeField.type == org.apache.thrift.protocol.TType.I16) {
						struct.mention_id = iprot.readI16();
						struct.setMention_idIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 9: // EQUIV_ID
					if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
						struct.equiv_id = iprot.readI32();
						struct.setEquiv_idIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 10: // PARENT_ID
					if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
						struct.parent_id = iprot.readI32();
						struct.setParent_idIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 11: // DEPENDENCY_PATH
					if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						struct.dependency_path = iprot.readString();
						struct.setDependency_pathIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				case 12: // LABELS
					if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
						{
							org.apache.thrift.protocol.TMap _map14 = iprot.readMapBegin();
							struct.labels = new HashMap<String, List<Label>>(2 * _map14.size);
							for (int _i15 = 0; _i15 < _map14.size; ++_i15) {
								String _key16;
								List<Label> _val17;
								_key16 = iprot.readString();
								{
									org.apache.thrift.protocol.TList _list18 = iprot.readListBegin();
									_val17 = new ArrayList<Label>(_list18.size);
									for (int _i19 = 0; _i19 < _list18.size; ++_i19) {
										Label _elem20;
										_elem20 = new Label();
										_elem20.read(iprot);
										_val17.add(_elem20);
									}
									iprot.readListEnd();
								}
								struct.labels.put(_key16, _val17);
							}
							iprot.readMapEnd();
						}
						struct.setLabelsIsSet(true);
					} else {
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					break;
				default:
					org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();

			// check for required fields of primitive type, which can't be checked in the validate method
			struct.validate();
		}

		@Override
		public void write(org.apache.thrift.protocol.TProtocol oprot, Token struct) throws org.apache.thrift.TException {
			struct.validate();

			oprot.writeStructBegin(STRUCT_DESC);
			oprot.writeFieldBegin(TOKEN_NUM_FIELD_DESC);
			oprot.writeI32(struct.token_num);
			oprot.writeFieldEnd();
			if (struct.token != null) {
				oprot.writeFieldBegin(TOKEN_FIELD_DESC);
				oprot.writeString(struct.token);
				oprot.writeFieldEnd();
			}
			if (struct.offsets != null) {
				if (struct.isSetOffsets()) {
					oprot.writeFieldBegin(OFFSETS_FIELD_DESC);
					{
						oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.I32,
								org.apache.thrift.protocol.TType.STRUCT, struct.offsets.size()));
						for (Map.Entry<OffsetType, Offset> _iter21 : struct.offsets.entrySet()) {
							oprot.writeI32(_iter21.getKey().getValue());
							_iter21.getValue().write(oprot);
						}
						oprot.writeMapEnd();
					}
					oprot.writeFieldEnd();
				}
			}
			if (struct.isSetSentence_pos()) {
				oprot.writeFieldBegin(SENTENCE_POS_FIELD_DESC);
				oprot.writeI32(struct.sentence_pos);
				oprot.writeFieldEnd();
			}
			if (struct.lemma != null) {
				if (struct.isSetLemma()) {
					oprot.writeFieldBegin(LEMMA_FIELD_DESC);
					oprot.writeString(struct.lemma);
					oprot.writeFieldEnd();
				}
			}
			if (struct.pos != null) {
				if (struct.isSetPos()) {
					oprot.writeFieldBegin(POS_FIELD_DESC);
					oprot.writeString(struct.pos);
					oprot.writeFieldEnd();
				}
			}
			if (struct.entity_type != null) {
				if (struct.isSetEntity_type()) {
					oprot.writeFieldBegin(ENTITY_TYPE_FIELD_DESC);
					oprot.writeI32(struct.entity_type.getValue());
					oprot.writeFieldEnd();
				}
			}
			if (struct.isSetMention_id()) {
				oprot.writeFieldBegin(MENTION_ID_FIELD_DESC);
				oprot.writeI16(struct.mention_id);
				oprot.writeFieldEnd();
			}
			if (struct.isSetEquiv_id()) {
				oprot.writeFieldBegin(EQUIV_ID_FIELD_DESC);
				oprot.writeI32(struct.equiv_id);
				oprot.writeFieldEnd();
			}
			if (struct.isSetParent_id()) {
				oprot.writeFieldBegin(PARENT_ID_FIELD_DESC);
				oprot.writeI32(struct.parent_id);
				oprot.writeFieldEnd();
			}
			if (struct.dependency_path != null) {
				if (struct.isSetDependency_path()) {
					oprot.writeFieldBegin(DEPENDENCY_PATH_FIELD_DESC);
					oprot.writeString(struct.dependency_path);
					oprot.writeFieldEnd();
				}
			}
			if (struct.labels != null) {
				if (struct.isSetLabels()) {
					oprot.writeFieldBegin(LABELS_FIELD_DESC);
					{
						oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING,
								org.apache.thrift.protocol.TType.LIST, struct.labels.size()));
						for (Map.Entry<String, List<Label>> _iter22 : struct.labels.entrySet()) {
							oprot.writeString(_iter22.getKey());
							{
								oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT,
										_iter22.getValue().size()));
								for (Label _iter23 : _iter22.getValue()) {
									_iter23.write(oprot);
								}
								oprot.writeListEnd();
							}
						}
						oprot.writeMapEnd();
					}
					oprot.writeFieldEnd();
				}
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

	}

	private static class TokenTupleSchemeFactory implements SchemeFactory {
		@Override
		public TokenTupleScheme getScheme() {
			return new TokenTupleScheme();
		}
	}

	private static class TokenTupleScheme extends TupleScheme<Token> {

		@Override
		public void write(org.apache.thrift.protocol.TProtocol prot, Token struct) throws org.apache.thrift.TException {
			TTupleProtocol oprot = (TTupleProtocol) prot;
			BitSet optionals = new BitSet();
			if (struct.isSetToken_num()) {
				optionals.set(0);
			}
			if (struct.isSetToken()) {
				optionals.set(1);
			}
			if (struct.isSetOffsets()) {
				optionals.set(2);
			}
			if (struct.isSetSentence_pos()) {
				optionals.set(3);
			}
			if (struct.isSetLemma()) {
				optionals.set(4);
			}
			if (struct.isSetPos()) {
				optionals.set(5);
			}
			if (struct.isSetEntity_type()) {
				optionals.set(6);
			}
			if (struct.isSetMention_id()) {
				optionals.set(7);
			}
			if (struct.isSetEquiv_id()) {
				optionals.set(8);
			}
			if (struct.isSetParent_id()) {
				optionals.set(9);
			}
			if (struct.isSetDependency_path()) {
				optionals.set(10);
			}
			if (struct.isSetLabels()) {
				optionals.set(11);
			}
			oprot.writeBitSet(optionals, 12);
			if (struct.isSetToken_num()) {
				oprot.writeI32(struct.token_num);
			}
			if (struct.isSetToken()) {
				oprot.writeString(struct.token);
			}
			if (struct.isSetOffsets()) {
				{
					oprot.writeI32(struct.offsets.size());
					for (Map.Entry<OffsetType, Offset> _iter24 : struct.offsets.entrySet()) {
						oprot.writeI32(_iter24.getKey().getValue());
						_iter24.getValue().write(oprot);
					}
				}
			}
			if (struct.isSetSentence_pos()) {
				oprot.writeI32(struct.sentence_pos);
			}
			if (struct.isSetLemma()) {
				oprot.writeString(struct.lemma);
			}
			if (struct.isSetPos()) {
				oprot.writeString(struct.pos);
			}
			if (struct.isSetEntity_type()) {
				oprot.writeI32(struct.entity_type.getValue());
			}
			if (struct.isSetMention_id()) {
				oprot.writeI16(struct.mention_id);
			}
			if (struct.isSetEquiv_id()) {
				oprot.writeI32(struct.equiv_id);
			}
			if (struct.isSetParent_id()) {
				oprot.writeI32(struct.parent_id);
			}
			if (struct.isSetDependency_path()) {
				oprot.writeString(struct.dependency_path);
			}
			if (struct.isSetLabels()) {
				{
					oprot.writeI32(struct.labels.size());
					for (Map.Entry<String, List<Label>> _iter25 : struct.labels.entrySet()) {
						oprot.writeString(_iter25.getKey());
						{
							oprot.writeI32(_iter25.getValue().size());
							for (Label _iter26 : _iter25.getValue()) {
								_iter26.write(oprot);
							}
						}
					}
				}
			}
		}

		@Override
		public void read(org.apache.thrift.protocol.TProtocol prot, Token struct) throws org.apache.thrift.TException {
			TTupleProtocol iprot = (TTupleProtocol) prot;
			BitSet incoming = iprot.readBitSet(12);
			if (incoming.get(0)) {
				struct.token_num = iprot.readI32();
				struct.setToken_numIsSet(true);
			}
			if (incoming.get(1)) {
				struct.token = iprot.readString();
				struct.setTokenIsSet(true);
			}
			if (incoming.get(2)) {
				{
					org.apache.thrift.protocol.TMap _map27 = new org.apache.thrift.protocol.TMap(
							org.apache.thrift.protocol.TType.I32, org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
					struct.offsets = new HashMap<OffsetType, Offset>(2 * _map27.size);
					for (int _i28 = 0; _i28 < _map27.size; ++_i28) {
						OffsetType _key29;
						Offset _val30;
						_key29 = OffsetType.findByValue(iprot.readI32());
						_val30 = new Offset();
						_val30.read(iprot);
						struct.offsets.put(_key29, _val30);
					}
				}
				struct.setOffsetsIsSet(true);
			}
			if (incoming.get(3)) {
				struct.sentence_pos = iprot.readI32();
				struct.setSentence_posIsSet(true);
			}
			if (incoming.get(4)) {
				struct.lemma = iprot.readString();
				struct.setLemmaIsSet(true);
			}
			if (incoming.get(5)) {
				struct.pos = iprot.readString();
				struct.setPosIsSet(true);
			}
			if (incoming.get(6)) {
				struct.entity_type = EntityType.findByValue(iprot.readI32());
				struct.setEntity_typeIsSet(true);
			}
			if (incoming.get(7)) {
				struct.mention_id = iprot.readI16();
				struct.setMention_idIsSet(true);
			}
			if (incoming.get(8)) {
				struct.equiv_id = iprot.readI32();
				struct.setEquiv_idIsSet(true);
			}
			if (incoming.get(9)) {
				struct.parent_id = iprot.readI32();
				struct.setParent_idIsSet(true);
			}
			if (incoming.get(10)) {
				struct.dependency_path = iprot.readString();
				struct.setDependency_pathIsSet(true);
			}
			if (incoming.get(11)) {
				{
					org.apache.thrift.protocol.TMap _map31 = new org.apache.thrift.protocol.TMap(
							org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.LIST, iprot.readI32());
					struct.labels = new HashMap<String, List<Label>>(2 * _map31.size);
					for (int _i32 = 0; _i32 < _map31.size; ++_i32) {
						String _key33;
						List<Label> _val34;
						_key33 = iprot.readString();
						{
							org.apache.thrift.protocol.TList _list35 = new org.apache.thrift.protocol.TList(
									org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
							_val34 = new ArrayList<Label>(_list35.size);
							for (int _i36 = 0; _i36 < _list35.size; ++_i36) {
								Label _elem37;
								_elem37 = new Label();
								_elem37.read(iprot);
								_val34.add(_elem37);
							}
						}
						struct.labels.put(_key33, _val34);
					}
				}
				struct.setLabelsIsSet(true);
			}
		}
	}

}
